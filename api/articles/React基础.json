{"title":"React基础","uid":"0cc9f247ec8cd6a003267063f354c1c2","slug":"React基础","date":"2022-06-07T14:24:09.000Z","updated":"2022-06-12T13:45:09.903Z","comments":true,"path":"api/articles/React基础.json","keywords":null,"cover":"static\\img\\photo-1496449903678-68ddcb189a24.jpg","content":"<h2 id=\"React基础\"><a href=\"#React基础\" class=\"headerlink\" title=\"React基础\"></a>React基础</h2><h5 id=\"react安装\"><a href=\"#react安装\" class=\"headerlink\" title=\"react安装\"></a>react安装</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">npm install -g create-react-app &#x2F;&#x2F; 全局安装</code></pre>\n\n<h5 id=\"创建一个项目\"><a href=\"#创建一个项目\" class=\"headerlink\" title=\"创建一个项目\"></a>创建一个项目</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">create-react-app 项目名</code></pre>\n\n<h5 id=\"不想全局安装可以使用npx方式\"><a href=\"#不想全局安装可以使用npx方式\" class=\"headerlink\" title=\"不想全局安装可以使用npx方式\"></a>不想全局安装可以使用npx方式</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">npx create-react-app 项目名\n&#x2F;&#x2F; 需要等待一段时间,在等待时间内实际是安装react库\n&#x2F;&#x2F; react: react顶级库\n&#x2F;&#x2F; react-dom: web的react运行环境 比如app端的react-native\n&#x2F;&#x2F; react-scripts: 包含运行和打包react应用程序的所有脚本配置\n&#x2F;&#x2F; 安装成功后会生成如下的目录结构\n|-- README.md 使用方法的文档\n|-- node_modules 所有依赖安装的目录\n|-- package-lock.json 锁定安装时包的版本号，确保多人开发时依赖能保持一致\n|-- package.json 下载的安装包插件\n|-- public  静态资源公共目录\n|-- src 源代码目录</code></pre>\n\n<h5 id=\"npm安装失败\"><a href=\"#npm安装失败\" class=\"headerlink\" title=\"npm安装失败\"></a>npm安装失败</h5><ul>\n<li>切换npm镜像源</li>\n<li>使用yarn安装</li>\n<li>删除<code>node_modules</code>及package-lock.json重新执行 <code>npm install</code></li>\n<li>清除npm缓存 <code>npm cache clean --force</code> 再执行 <code>npm install</code></li>\n</ul>\n<h5 id=\"react基本结构\"><a href=\"#react基本结构\" class=\"headerlink\" title=\"react基本结构\"></a>react基本结构</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 从react的包当中引入react,只要写react.js组件就必须引入\nimport React from &#39;react&#39;\n&#x2F;&#x2F; react-dom可以把组件渲染到web页面\nimport ReactDOM from &#39;react-dom&#39;\n&#x2F;&#x2F; react-dom中有一个render方法,负责将组件渲染与构造dom树,然后插入到页面元素上\nReactDOM.render(&#39;组件名&#39;,document.getElementById(&#39;挂载的页面id节点&#39;))\n</code></pre>\n\n<h5 id=\"JSX语法\"><a href=\"#JSX语法\" class=\"headerlink\" title=\"JSX语法\"></a>JSX语法</h5><ul>\n<li>JSX将HTMl语法直接加入到JavaScript代码中</li>\n<li>由Babel的JSX编译器实现</li>\n<li>通过编译时会转换为纯JavaScript</li>\n</ul>\n<h5 id=\"JSX原理\"><a href=\"#JSX原理\" class=\"headerlink\" title=\"JSX原理\"></a>JSX原理</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 要明白JSX的原理，需要先明白如何用 JavaScript 对象来表现一个 DOM 元素的结构? \n&#x2F;&#x2F;基本结构\ndiv class&#x3D;&#39;app&#39; id&#x3D;&#39;appRoot&#39;&gt;  \n&lt;h1 class&#x3D;&#39;title&#39;&gt;欢迎进入React的世界&lt;&#x2F;h1&gt; \n&lt;p&gt;    \nReact.js 是一个帮助你构建页面 UI 的库  \n&#x2F;p&gt; \n&lt;&#x2F;div&gt; \n&#x2F;&#x2F; 使用JavaScript对象\n&#123;  tag: &#39;div&#39;,\nattrs: &#123; className: &#39;app&#39;, id: &#39;appRoot&#39;&#125;,  \nchildren: [    \n&#123; tag: &#39;h1&#39;, \nattrs: &#123; className: &#39;title&#39; &#125;,\nchildren: [&#39;欢迎进入React的世界&#39;] &#125;, \n&#123;  \n  tag: &#39;p&#39;, \n  attrs: null, \n  children: [&#39;React.js 是一个构建页面 UI 的库&#39;]    \n  &#125;  \n  ] \n &#125;\n &#x2F;*\nJavaScript 写起来太长了，结构看起来又不清晰，用 HTML 的方式写起来就方便很多了\n React.js 就把 JavaScript 的语法扩展了一下\n 让 JavaScript 语言能够支持这种直接在 JavaScript 代码里面编写类似 HTML 标签结构的语法\n 编译的过程会把类似 HTML 的 JSX 结构转换成 JavaScript 的对象结构\n*&#x2F;\n&#x2F;&#x2F; react编译前代码\nimport React from &#39;react&#39; \nimport ReactDOM from &#39;react-dom&#39;\nclass App extends React.Component &#123; \n  render () &#123;\n    return (\n      &lt;div className&#x3D;&#39;app&#39; id&#x3D;&#39;appRoot&#39;&gt; \n      &lt;h1 className&#x3D;&#39;title&#39;&gt;欢迎进入React的世界&lt;&#x2F;h1&gt;\n      &lt;p&gt;\n      React.js 是一个构建页面 UI 的库\n      &lt;&#x2F;p&gt;\n      &lt;&#x2F;div&gt; \n      ) \n      &#125; \n     &#125;\nReactDOM.render(    &lt;App &#x2F;&gt;,  document.getElementById(&#39;root&#39;) )\n&#x2F;&#x2F; react编译后代码\nimport React from &#39;react&#39; \nimport ReactDOM from &#39;react-dom&#39;\nclass App extends React.Component &#123;  \n  render () &#123;\n    return (\n      React.createElement(\n      &quot;div&quot;,\n      &#123; \n        assName: &#39;app&#39;,\n        id: &#39;appRoot&#39;\n      &#125;,\n      React.createElement(&quot;h1&quot;, \n      &#123; \n      className: &#39;title&#39; \n      &#125;,          \n      &quot;欢迎进入React的世界&quot;        \n      ),        \n      React.createElement(&quot;p&quot;,\n                           null,          \n                           &quot;React.js 是一个构建页面 UI 的库&quot;        \n                           )      \n                         )    \n                       )  \n                     &#125; \n                   &#125;\nReactDOM.render(    React.createElement(App),  document.getElementById(&#39;root&#39;) )\n&#x2F;&#x2F; React.createElement会构建一个 JavaScript 对象来描述你 HTML 结构的信息，包括标签名、属性、 还有子元素等, 语法为\n&#x2F;&#x2F; 编译顺序 JSX —使用react构造组件，bable进行编译—&gt; JavaScript对象 — ReactDOM.render() —&gt;DOM 元素 —&gt;插入页面</code></pre>\n\n<h5 id=\"class组件\"><a href=\"#class组件\" class=\"headerlink\" title=\"class组件\"></a>class组件</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; es6 class组件其实就是一个构造器,每次使用组件都相当于实列化组件\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\nclass App extends React.Component &#123;  \n  render () &#123;    \n    return (          \n      &lt;h1&gt;欢迎进入React的世界&lt;&#x2F;h1&gt;    \n    )  \n  &#125; \n&#125; \n&#x2F;*\nconst app &#x3D; new App(&#123;\n  name: &#39;react&#39;\n&#125;).render()\n*&#x2F;\nReactDOM.render(  &lt;App&#x2F;&gt;,  document.getElementById(&#39;root&#39;) )</code></pre>\n\n<h5 id=\"函数式组件\"><a href=\"#函数式组件\" class=\"headerlink\" title=\"函数式组件\"></a>函数式组件</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">import React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\n&#x2F;&#x2F; 函数式组件 组件名必须大写\nconst App &#x3D; () &#x3D;&gt; &lt;h1&gt;欢迎进入React的世界&lt;&#x2F;h1&gt; \n\nReactDOM.render(\n  &lt;App&#x2F;&gt;\n  document.getElementById(&#39;root&#39;)\n)</code></pre>\n\n<h5 id=\"组件样式\"><a href=\"#组件样式\" class=\"headerlink\" title=\"组件样式\"></a>组件样式</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; react中给虚拟dom添加行内样式,需要使用表达式传入样式对象的方式实现\nconst App &#x3D; () &#x3D;&gt; &lt;h1 style&#x3D;&#123;&#123;color: &#39;red&#39;，fontSize: &#39;14px&#39;&#125;&#125;&gt;\n欢迎进入React的世界\n&lt;&#x2F;h1&gt;\n&#x2F;&#x2F; 给元素添加类名\nconst App &#x3D; () &#x3D;&gt; &lt;h1 clssName&#x3D;&quot;styleName&quot;&gt;\n欢迎进入React的世界\n&lt;&#x2F;h1&gt;\n&#x2F;&#x2F; 由于css的class样式跟js的class同名因而发起冲突因此react中class为className\n&#x2F;&#x2F; label中的for为htmlFor\n&#x2F;&#x2F; class &#x3D;&#x3D;&gt; className for &#x3D;&#x3D;&gt; htmlFor(label)</code></pre>\n\n<h5 id=\"事件绑定\"><a href=\"#事件绑定\" class=\"headerlink\" title=\"事件绑定\"></a>事件绑定</h5><ul>\n<li><code>react</code>事件采用 on+事件名方式绑定</li>\n<li><code>react</code>的事件是以驼峰命名显示<code>onClick</code></li>\n<li><code>react</code>的事件并不是原生事件,而是合成事件</li>\n</ul>\n<h6 id=\"因为this指向与函数执行的原因因此\"><a href=\"#因为this指向与函数执行的原因因此\" class=\"headerlink\" title=\"因为this指向与函数执行的原因因此\"></a>因为this指向与函数执行的原因因此</h6><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;react推荐在组件内使用箭头函数定义一个方法\nconst App &#x3D; () &#x3D;&gt; &lt;h1 clssName&#x3D;&quot;styleName&quot; onClick&#x3D;&#123; handlerClick() &#125;&gt;\nhandlerClick &#x3D; () &#x3D;&gt; &#123;\n console.log(123)\n&#125;\nconst App &#x3D; () &#x3D;&gt; &lt;h1 clssName&#x3D;&quot;styleName&quot; onClick&#x3D;&#123; this.handlerClick  &#125;&gt;\nhandlerClick()&#123;\n console.log(123)\n&#125;\n&#x2F;*react不推荐\n直接在组件内定义一个非箭头函数方法,然后render里直接使用onClick&#x3D;&#123;this.handlerClick.bind(this)&#125;\n*&#x2F;\n&#x2F;&#x2F;直接在render里写行内的箭头函数(不推荐) \nconst App &#x3D; () &#x3D;&gt; &lt;h1 clssName&#x3D;&quot;styleName&quot; onClick&#x3D;&#123; () &#x3D;&gt; &#123; this.handlerClick() &#125; &#125;&gt;\nhandlerClick()&#123;\n console.log(123)\n&#125;</code></pre>\n\n<h5 id=\"Event对象\"><a href=\"#Event对象\" class=\"headerlink\" title=\"Event对象\"></a>Event对象</h5><p>和普通浏览器一样，事件handler会被自动传入一个 event 对象，这个对象和普通的浏览器 event 对 象所包含的方法和属性都基本一致。不同的是 React中的 event 对象并不是浏览器提供的，而是它自 己内部所构建的。它同样具有 event.stopPropagation 、 event.preventDefault 这种常用的方法</p>\n<h5 id=\"Ref应用\"><a href=\"#Ref应用\" class=\"headerlink\" title=\"Ref应用\"></a>Ref应用</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 给标签设置ref\nmyRef &#x3D; React.createRef() &#x2F;&#x2F; 创建ref\n    &lt;div&gt;\n        &lt;input type&#x3D;&#39;text&#39; ref&#x3D;&#123;this.myRef&#125;&gt;&lt;&#x2F;input&gt; &#x2F;&#x2F; 引用ref\n        &lt;button onClick&#x3D;&#123; () &#x3D;&gt; &#123;\n          console.log(this.myRef.current.value)\n        &#125;&#125;&gt;点击&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;</code></pre>\n\n<h5 id=\"状态-state\"><a href=\"#状态-state\" class=\"headerlink\" title=\"状态(state)\"></a>状态(state)</h5><p>状态就是组件描述某种显示情况的数据，由组件自己设置和更改，也就是说由组件自己维护，使用状态 的目的就是为了在不同的状态下使组件的显示不同</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 定义状态的两种方式\nimport React, &#123; Component &#125; from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\n\nclass App extends Component &#123;\n &#x2F;* state &#x3D; &#123;\n    name: &#39;React&#39;,\n    isLiked: false\n  &#125; *&#x2F;\n  constructor()&#123;\n    super()\n    this.state &#x3D; &#123;\n      name: &#39;React&#39;,\n      isLiked: false\n    &#125;\n  &#125;\n  handleBtnClick &#x3D; () &#x3D;&gt; &#123;\n    this.setState(&#123;\n      isLiked: !this.state.isLiked\n    &#125;)\n  &#125;\n  render () &#123;\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;欢迎来到&#123; this.state.name &#125; 的世界&lt;&#x2F;h1&gt;\n        &lt;button onClick&#x3D;&#123;this.handleBtnClick&#125;&gt;\n        &#123;\n          this.state.isLiked ? &#39;取消&#39; : &#39;收藏&#39;\n        &#125;\n        &lt;button&gt;\n      &lt;&#x2F;div&gt;\n    )\n  &#125;\n&#125;\n&#x2F;*this.state 是纯js对象,在vue中，data属性是利用 Object.defineProperty 处理过的，更改 data的 数据的时候会触发数据的 getter 和 setter ，但是React中没有做这样的处理，如果直接更改的话， react是无法得知的，所以，需要使用特殊的更改状态的方法 setState *&#x2F;</code></pre>\n\n<p>setState有两个参数第一个参数可以是对象,也可以是方法return一个对象</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 参数是对象\nthis.setState(&#123;\n  isLiked: !this.state.isLiked\n&#125;)\n&#x2F;&#x2F; 参数是方法\nthis.setState((preState, props) &#x3D;&gt; &#123;\n  return &#123;\n    isLiked: !preState.isLiked \n  &#125;\n&#125;)\n&#x2F;*\n注意的是这个方法接收两个参数，第一个是上一次的state, 第二个是props setState 是异步的，所以想要获取到新的state，没有办法获取，就有了第二个参数，这是一个可选 的回调函数\n*&#x2F;\nthis.setState((preState, props) &#x3D;&gt; &#123;\n  return &#123;\n    isLiked: !preState.isLiked\n  &#125;\n&#125;, () &#x3D;&gt; &#123;\n  console.log(&#39;回调里的&#39;,this.state.isLiked)\n&#125; )</code></pre>\n\n<h5 id=\"属性-props\"><a href=\"#属性-props\" class=\"headerlink\" title=\"属性(props)\"></a>属性(props)</h5><p>props 是正常是外部传入的，组件内部也可以通过一些方式来初始化的设置，属性不能被组件自己更 改，但是你可以通过父组件主动重新渲染的方式来传入新的 props<br>属性是描述性质、特点的，组件自己不能随意更改。<br>之前的组件代码里面有 props 的简单使用，总的来说，在使用一个组件的时候，可以把参数放在标签的 属性当中，所有的属性都会作为组件 props 对象的键值。通过箭头函数创建的组件，需要通过函数的 参数来接收 props </p>\n<ul>\n<li>在组件上通过key&#x3D;value 写属性,通过this.props获取属性,这样组件的可复用性提高了</li>\n<li>注意在传参数时候，如果写成isShow&#x3D;”true” 那么这是一个字符串    如果写成isShow&#x3D;{true} 这个<br>是布尔值</li>\n<li>{…对象}  展开赋值</li>\n<li>默认属性值</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 父组件\nimport React, &#123; Component &#125; from &#39;react&#39;\nimport Navbar from &#39;.&#x2F;Navbar&#x2F;index&#39;\nexport default class App extends Component &#123;\n    state &#x3D; &#123;&#125;\n    render() &#123;\n    return (\n      &lt;div&gt;\n          &lt;div&gt;\n           &lt;h2&gt;首页&lt;&#x2F;h2&gt;\n          &lt;Navbar title&#x3D;&quot;首页&quot; leftShow&#x3D;&#123;false&#125;&#x2F;&gt;\n          &lt;&#x2F;div&gt;\n          &lt;div&gt;\n            &lt;h2&gt;列表&lt;&#x2F;h2&gt;\n            &lt;Navbar title&#x3D;&quot;列表&quot; leftShow&#x3D;&#123;true&#125;&#x2F;&gt;\n          &lt;&#x2F;div&gt;\n          &lt;div&gt;\n            &lt;h2&gt;购物车&lt;&#x2F;h2&gt;\n            &lt;Navbar title&#x3D;&quot;购物车&quot; leftShow&#x3D;&#123;true&#125;&#x2F;&gt;\n          &lt;&#x2F;div&gt;\n      &lt;&#x2F;div&gt;\n    )\n  &#125;\n&#125;\n&#x2F;&#x2F; 子组件\nimport React, &#123; Component &#125; from &#39;react&#39;\nexport default class Navbar extends Component &#123;\n  render() &#123;\n    let &#123; title,leftShow &#125; &#x3D; this.props\n    return (\n      &lt;div&gt;\n          &#123;leftShow &amp;&amp; &lt;button&gt;返回&lt;&#x2F;button&gt;&#125;\n          &#123; title &#125;\n          &lt;button&gt;home&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    )\n  &#125;\n&#125;\n</code></pre>\n\n<p>prop-types属性验证</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import propTypes from &#39;prop-types&#39; &#x2F;&#x2F; 引入属性验证包\n&#x2F;&#x2F; 需要验证的属性类属性\n*.propTypes &#x3D; &#123;\n  name: propTypes.string,\n  age: propTypes.number\n&#125;\n&#x2F;&#x2F; 在class中写法\nstatic propTypes &#x3D; &#123;\n  myname: propTypes.string,\n   myshow: propTypes.bool\n&#125;</code></pre>\n\n<h5 id=\"属性与状态\"><a href=\"#属性与状态\" class=\"headerlink\" title=\"属性与状态\"></a>属性与状态</h5><p>相似点：都是纯js对象，都会触发render更新，都具有确定性（状态&#x2F;属性相同，结果相同）</p>\n<p>不同点： </p>\n<ol>\n<li>属性能从父组件获取，状态不能 </li>\n<li>属性可以由父组件修改，状态不能 </li>\n<li>属性能在内部设置默认值，状态也可以，设置方式不一样 </li>\n<li>属性不在组件内部修改，状态要在组件内部修改 </li>\n<li>属性能设置子组件初始值，状态不可以 </li>\n<li>属性可以修改子组件的值，状态不可以</li>\n</ol>\n<p>state 的主要作用是用于组件保存、控制、修改自己的可变状态。 state 在组件内部初始化，可以被 组件自身修改，而外部不能访问也不能修改。你可以认为 state 是一个局部的、只能被组件自身控制 的数据源。 state 中状态可以通过 this.setState 方法进行更新， setState 会导致组件的重新渲 染。</p>\n<p>props 的主要作用是让使用该组件的父组件可以传入参数来配置该组件。它是外部传进来的配置参 数，组件内部无法控制也无法修改。除非外部组件主动传入新的 props ，否则组件的 props 永远保持 不变。</p>\n<p>没有 state 的组件叫无状态组件（stateless component），设置了 state 的叫做有状态组件 （stateful component）。因为状态会带来管理的复杂性，我们尽量多地写无状态组件，尽量少地写有 状态的组件。这样会降低代码维护的难度，也会在一定程度上增强组件的可复用性。</p>\n<h5 id=\"渲染数据\"><a href=\"#渲染数据\" class=\"headerlink\" title=\"渲染数据\"></a>渲染数据</h5>","text":"React基础react安装npm install -g create-react-app &#x2F;&#x2F; 全局安装 创建一个项目create-react-app 项目名 不想全局安装可以使用npx方式npx create-react-app 项目名 &#x2F;&#x...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"技术","slug":"技术","count":15,"path":"api/categories/技术.json"}],"tags":[{"name":"React基础","slug":"React基础","count":1,"path":"api/tags/React基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">React基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#react%E5%AE%89%E8%A3%85\"><span class=\"toc-text\">react安装</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE\"><span class=\"toc-text\">创建一个项目</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E6%83%B3%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8npx%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">不想全局安装可以使用npx方式</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#npm%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5\"><span class=\"toc-text\">npm安装失败</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#react%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">react基本结构</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#JSX%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">JSX语法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#JSX%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">JSX原理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#class%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">class组件</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">函数式组件</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F\"><span class=\"toc-text\">组件样式</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A\"><span class=\"toc-text\">事件绑定</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%9B%A0%E4%B8%BAthis%E6%8C%87%E5%90%91%E4%B8%8E%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%9B%A0%E6%AD%A4\"><span class=\"toc-text\">因为this指向与函数执行的原因因此</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Event%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">Event对象</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Ref%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">Ref应用</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%8A%B6%E6%80%81-state\"><span class=\"toc-text\">状态(state)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%B1%9E%E6%80%A7-props\"><span class=\"toc-text\">属性(props)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">属性与状态</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%B8%B2%E6%9F%93%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">渲染数据</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"小提琴","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"我见青山多妩媚，料青山、见我应如是。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"axios","uid":"33876cf3e210da358d8e4b065eea88e6","slug":"请求拦截器响应拦截器","date":"2022-06-12T13:21:42.000Z","updated":"2022-06-12T13:38:42.465Z","comments":true,"path":"api/articles/请求拦截器响应拦截器.json","keywords":null,"cover":"static\\img\\photo-1516166328576-82e16a127024.jpg","text":"请求拦截器响应拦截器axios有两种拦截器分别为请求拦截器和响应拦截器 请求拦截器: 在向后台发起请求时进行必要处理操作 运用场景如,添加统一cookie,请求体加验证,设置请求头 等同于每个请求都做了相同操作 响应拦截器: 请求得到响应后对响应体做一些处理 运用场景如: 判断登...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"技术","slug":"技术","count":15,"path":"api/categories/技术.json"}],"tags":[{"name":"axios","slug":"axios","count":1,"path":"api/tags/axios.json"}],"author":{"name":"小提琴","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"我见青山多妩媚，料青山、见我应如是。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Minxins","uid":"fa9186e3fcd1aa3f18e4e09eef185770","slug":"Mixins","date":"2022-06-06T13:30:11.000Z","updated":"2022-06-06T14:49:31.239Z","comments":true,"path":"api/articles/Mixins.json","keywords":null,"cover":"static\\img\\photo-1496449903678-68ddcb189a24.jpg","text":"Mixins分发Vue组件复用功能 mixins是一个js对象,它可以包含我们组件中script的任意选项 类如: data components methods created computed 等等 将组件中共用功能以对象的方式传入mixins选项 当组件使用mixins对象...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"技术","slug":"技术","count":15,"path":"api/categories/技术.json"}],"tags":[{"name":"Vue","slug":"Vue","count":3,"path":"api/tags/Vue.json"},{"name":"JavaScirpt","slug":"JavaScirpt","count":1,"path":"api/tags/JavaScirpt.json"}],"author":{"name":"小提琴","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"我见青山多妩媚，料青山、见我应如是。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}