{"title":"递归树函数柯里化","uid":"c630e8b20885330b03b488ffd97cdd35","slug":"递归树函数柯里化","date":"2022-08-24T14:33:12.000Z","updated":"2022-08-24T14:33:53.798Z","comments":true,"path":"api/articles/递归树函数柯里化.json","keywords":null,"cover":"static\\img\\photo-1591693117893-7cbfc0a7ac69.jpg","content":"<h3 id=\"递归树函数柯里化\"><a href=\"#递归树函数柯里化\" class=\"headerlink\" title=\"递归树函数柯里化\"></a>递归树函数柯里化</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;* 模拟递归树\n  首先树要有一个唯一的根节点已经若干个子节点\n  子节点的pid要等于父节点的id,通过标识判断子节点\n  是否属于父节点\n *&#x2F;\n   const obj &#x3D; [\n     &#123;\n       id: 1,\n       pid: 0,\n       name: &#39;主管&#39;\n     &#125;,\n     &#123;\n       id: 2,\n       pid: 1,\n       name: &#39;部门经理1&#39;\n     &#125;,\n     &#123;\n       id: 3,\n       pid: 1,\n       name: &#39;部门经理2&#39;\n     &#125;,\n     &#123;\n       id: 4,\n       pid:1,\n       name: &#39;部门经理3&#39;\n     &#125;,\n     &#123;\n       id: 5,\n       pid: 2,\n       name: &#39;员工1&#39;\n     &#125;,\n     &#123;\n       id: 6,\n       pid: 2,\n       name: &#39;员工2&#39;\n     &#125;,\n     &#123;\n       id: 7,\n       pid: 3,\n       name: &#39;员工3&#39;\n     &#125;,\n     &#123;\n       id: 8,\n       pid: 3,\n       name: &#39;员工4&#39;\n     &#125;\n   ]\n   &#x2F;* 通过传递过来的数组,和根节点进行判断 *&#x2F;\n   function a(arr,pid)&#123;\n     &#x2F;* 返回树形结构的数组 *&#x2F;\n       let result &#x3D; []\n       &#x2F;* 要取数组中的元素,使用循环遍历 *&#x2F;\n       arr.forEach((item,index) &#x3D;&gt; &#123;\n         &#x2F;* 判断参数的pid是否等于数组的pid\n           相等进行添加\n           使用递归调用的方式继续遍历数组\n           由于子节点pid等于父节点id,通过父节点id进行判断\n           接收递归的返回值并把它添加到children中\n          *&#x2F;\n        if(item.pid &#x3D;&#x3D;&#x3D; pid)&#123;\n           result.push(item)\n           const children &#x3D; a(arr,item.id) \n           children.length &amp;&amp; (item.children &#x3D; children)\n         &#125;\n     &#125;)\n     return result\n   &#125;\n   const a1 &#x3D; a(obj,0)\n   console.log(a1)</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;* 当一个函数连续调用多次时\n   add(1)(2)(3)(4)(5)\n   通过函数柯里化方式进行拆解\n   以闭包的方式每次返回一个函数\n   提升变量生命周期使用arguments的方式记录参数\n   重写toString方法\n   *&#x2F;\n function add()&#123;\n   let arg &#x3D; [...arguments]\n   const sum &#x3D; (...args) &#x3D;&gt; &#123;\n       arg.push(...args)\n       return sum\n   &#125;\n   &#x2F;* 重写toString *&#x2F;\n   sum.toString &#x3D; () &#x3D;&gt; &#123;\n     return arg.reduce((pre,item) &#x3D;&gt; pre +&#x3D; item)\n   &#125;\n   return sum\n &#125;\n &#x2F;* 当一个数组被作为文本值或者进行字符串连接操作时，将会自动调用其 toString 方法 *&#x2F;\n console.log(add(1)(2)(3)(4)(5) + &#39;&#39;)</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;函数柯里化是指将一个拥有多个参数的函数分解成接收一个函数及接收一个或多个参数的函数\n &#x2F;&#x2F;通过返回一个函数使其他函数可以传输入剩余参数调用\n   &#x2F;&#x2F; add匿名函数接受3个参数 返回 3个参数相加值\n   const add &#x3D; (a, b, c) &#x3D;&gt; a + b + c\n   &#x2F;&#x2F; a变量指向currying函数地址 实际是一个引用\n   &#x2F;&#x2F; 实例a接收一个函数 和 一个参数\n   const a &#x3D; currying(add, 1)\n   console.log(a(2, 3))\n   &#x2F;&#x2F; currying接收一个函数 多个参数不等\n   function currying(fn, ...args)&#123;\n     &#x2F;&#x2F; function的length，就是第一个具有默认值之前的参数个数\n     &#x2F;&#x2F; length 是函数对象的一个属性值，指该函数有多少个必须要传入的参数，即形参的个数。\n     &#x2F;&#x2F;形参的数量不包括剩余参数个数，仅包括第一个具有默认值之前的参数个数\n     const length &#x3D; fn.length\n     &#x2F;* console.log(fn.__proto__, fn.length) *&#x2F;\n     let allArgs &#x3D; [...args] &#x2F;&#x2F; args的参数展开到一个数组\n     const res &#x3D; (...arg) &#x3D;&gt; &#123;\n       console.log(arg,1111111)\n         &#x2F;* console.log(arg) *&#x2F;\n         allArgs &#x3D; [...allArgs, ...arg]\n         if(allArgs.length &#x3D;&#x3D;&#x3D; length)&#123;\n           return fn(...allArgs)\n         &#125; else &#123;\n           return res\n         &#125;\n     &#125;\n     return res &#x2F;&#x2F; 返回一个方法\n   &#125;</code></pre>\n\n","feature":true,"text":"递归树函数柯里化&#x2F;* 模拟递归树 首先树要有一个唯一的根节点已经若干个子节点 子节点的pid要等于父节点的id,通过标识判断子节点 是否属于父节点 *&#x2F; const obj &#x3D; [ &#123; id: 1, pid: 0, name: &#39;主...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"技术","slug":"技术","count":18,"path":"api/categories/技术.json"}],"tags":[{"name":"ES6","slug":"ES6","count":8,"path":"api/tags/ES6.json"},{"name":"JavaScript","slug":"JavaScript","count":10,"path":"api/tags/JavaScript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%92%E5%BD%92%E6%A0%91%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96\"><span class=\"toc-text\">递归树函数柯里化</span></a></li></ol>","author":{"name":"小提琴","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"我见青山多妩媚，料青山、见我应如是。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"npm","uid":"506af269f13c75940f82dd6b0ee208bd","slug":"npm包的发布与管理","date":"2022-08-21T13:11:27.000Z","updated":"2022-08-24T14:33:02.509Z","comments":true,"path":"api/articles/npm包的发布与管理.json","keywords":null,"cover":"static\\img\\photo-1571361656693-d7602246ce3c.jpg","text":"npm包的发布与管理通过 npm init -y 进行默认初始化 或者 npm init 自己配置 注册 npm 账号 查看npm源地址是否是官方账号 npm config get registry 不是的话设置npm源地址 npm config set registry htt...","link":"","photos":[],"count_time":{"symbolsCount":682,"symbolsTime":"1 mins."},"categories":[{"name":"技术","slug":"技术","count":18,"path":"api/categories/技术.json"}],"tags":[{"name":"ES6","slug":"ES6","count":8,"path":"api/tags/ES6.json"},{"name":"JavaScript","slug":"JavaScript","count":10,"path":"api/tags/JavaScript.json"}],"author":{"name":"小提琴","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"我见青山多妩媚，料青山、见我应如是。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}