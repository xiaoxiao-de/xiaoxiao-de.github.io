{"title":"TypeScript","uid":"0aaa27c48e7b40c2bc96b31fb70803da","slug":"Typescript基础","date":"2022-09-01T14:29:12.000Z","updated":"2022-09-02T16:24:25.189Z","comments":true,"path":"api/articles/Typescript基础.json","keywords":null,"cover":"static\\img\\quot.jpg","content":"<h2 id=\"Typescript基础\"><a href=\"#Typescript基础\" class=\"headerlink\" title=\"Typescript基础\"></a>Typescript基础</h2><h5 id=\"基础类型\"><a href=\"#基础类型\" class=\"headerlink\" title=\"基础类型\"></a>基础类型</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">基本类型分为: Boolean Number String null undefined Symbol BigInt\nlet a:boolean &#x3D; true &#x2F;&#x2F; 布尔型\nlet b:string &#x3D; &quot;11&quot; &#x2F;&#x2F; 字符串\nlet c:number &#x3D; 1 &#x2F;&#x2F; 数值\nlet d:undefined &#x3D; undefined &#x2F;&#x2F; 未定义\nlet e:null &#x3D; null &#x2F;&#x2F; 空\n&#x2F;*\nvoid主要用在不关心调用者关心函数返回值的情况\nvoid也可以定义undefined和null类型\nundefined和null是所有类型的子类型,也就是说undefined类型的变量,可以赋值给String类型变量\n开启严格模式后null不能赋值为undefined\n*&#x2F;\nlet f:void &#x3D; undefined &#x2F;&#x2F; 空值</code></pre>\n\n<h5 id=\"any和unknown\"><a href=\"#any和unknown\" class=\"headerlink\" title=\"any和unknown\"></a>any和unknown</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">let q:any &#x3D; 1\nlet v:unknown &#x3D; 2\nv &#x3D; q\nconsole.log(v)\n&#x2F;*\nany和unknown一样他们可以赋值任何类型\n使用any的话就是失去了ts的检测机制\n当要使用any时可以考虑是否可以使用unknown\nunknown比any更严谨\nunknown不能赋值给其他类型\nunknown只能辅助使用unknown和any声明的对象\nunknown不能调用属性和方法\n*&#x2F;</code></pre>\n\n<h5 id=\"接口和对象类型\"><a href=\"#接口和对象类型\" class=\"headerlink\" title=\"接口和对象类型\"></a>接口和对象类型</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;*\ninterface(接口) 用于定义对象 类似一中约束\n使用接口约束时属性不能多也不能少必须按照接口的约束来\n *&#x2F;\ninterface Person&#123;\n  name: string,\n  age: number,\n&#125;\n&#x2F;*接口继承 *&#x2F;\ninterface Grid extends Person &#123;\n  sex: string\n&#125; \n&#x2F;* \n两个同名的会合并为一个\n*&#x2F;\ninterface Person &#123;\n  phone: string\n&#125;\nconst obj:Person &#x3D; &#123;\n  name: &#39;11&#39;,\n  age: 18,\n  phone: &#39;1111&#39;\n&#125;\n&#x2F;&#x2F; ?可选操作表示属性时可以不存在的\ninterface a&#123;\n  name?: string\n  callback: () &#x3D;&gt; void\n&#125;\n&#x2F;&#x2F; 只读属性readonly 不允许被赋值只能读取\n&#x2F;&#x2F; 一当定义了任意属性,确定属性和可选属性类型都是它的子集\ninterface b &#123;\n  readonly age: number,\n  [PropName:string]: any\n&#125;</code></pre>\n\n<h5 id=\"数组类型\"><a href=\"#数组类型\" class=\"headerlink\" title=\"数组类型\"></a>数组类型</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 数组类型\nlet n:number [] &#x3D; [1,2]\n&#x2F;&#x2F; 泛型数组\nlet g:Array&lt;string&gt; &#x3D; [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;]\n&#x2F;&#x2F; 接口表示数组\ninterface arr&#123;\n  [index:number]: string\n&#125;\nlet qa:arr &#x3D; [&#39;1&#39;,&#39;2&#39;]\n&#x2F;&#x2F; 多维数组 &#x3D;&gt; 二维数组\nlet qw:number [][] &#x3D; [[4,5],[7,8]]\n&#x2F;&#x2F; arguments类型数组 IArguments是ts内置arguments类型数组\nfunction Arr(...arg:any)&#123;\n  let q1:IArguments &#x3D; arguments\n&#125;</code></pre>\n\n<h5 id=\"函数扩展\"><a href=\"#函数扩展\" class=\"headerlink\" title=\"函数扩展\"></a>函数扩展</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 剩余参数函数\nconst fn &#x3D; (array:number[],...items:any[]):any[] &#x3D;&gt; &#123;\n  return items\n&#125;\nlet a:number &#x3D; [1,2,3]\nfn(a,&quot;2&quot;,&quot;s&quot;,&quot;s&quot;)\n&#x2F;* 函数重载\n重载是方法名字相同,而参数不同,返回类型可以相同也可以不同\n如果参数类型不同,则参数类型应设置为any\n参数数量不同你可以将不同的参数设置为可选\n*&#x2F;\nfunction fn(params:number):void\nfunction fn(params:string,params2:number):void\nfunction fn(params:any,params2?:any): void &#123;\n  console.log(params)\n  console.log(params2)\n&#125;\nfn(123)\nfn(&#39;123&#39;,456)</code></pre>\n\n<h5 id=\"联合类型\"><a href=\"#联合类型\" class=\"headerlink\" title=\"联合类型\"></a>联合类型</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 联合类型 &#x3D;&gt; 函数\nconst fn1 &#x3D; (some:number | boolean):boolean &#x3D;&gt; &#123;\n  return !!some\n&#125;\n&#x2F;* 交叉类型 \n 多种类型的集合,联合对象将具有联合类型的所有成员\n*&#x2F;\ninterface a11 &#123;\n  age: number,\n  height: number\n&#125;\ninterface a12 &#123;\n  sex:string\n&#125;\nconst a13 &#x3D; (man: a11 &amp; a12):a11 &amp; a12 &#x3D;&gt; &#123;\n  return man\n&#125;\n&#x2F;* 类型断言 \n语法  值 as 类型\n&lt;类型&gt;值\n类型断言只能够欺骗typescript编译器无法避免运行时的错误\n滥用类型断言可能会导致运行时错误\n类型断言是不具影响力的\n因为编译过程中会删除类型断言\n*&#x2F;\ninterface A1 &#123;\n  run: string\n&#125;\ninterface A2 &#123;\n  bulid: string\n&#125;\nconst fn3 &#x3D; (type:A1 | A2): string &#x3D;&gt; &#123;\n&#x2F;&#x2F; return (type as A1).run\nreturn (type as A2).bulid\n&#125;\n&#x2F;&#x2F; window.abc &#x3D; 123\n(window as any).abc &#x3D; 12</code></pre>\n\n<h5 id=\"类型推论\"><a href=\"#类型推论\" class=\"headerlink\" title=\"类型推论\"></a>类型推论</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;*\n类型推论\nTypescript会在没有明确的指定类型的时候推测出一个类型\n你声明变量没有定义类型也没有赋值这时Typescript会推断成any类型可以进行任何操作\n类型别名\ntype 可以给一个类型定义一个名字多用于符合类型 \n*&#x2F;\nlet str &#x3D;&quot;西&quot;\n&#x2F;&#x2F; 类型别名\ntype s &#x3D; string\nlet q1:s &#x3D; &#39;1&#39;\n&#x2F;&#x2F; 类型函数别名\ntype str1 &#x3D; () &#x3D;&gt; string\nlet q2:str1 &#x3D; () &#x3D;&gt; &quot;fds&quot;\n&#x2F;&#x2F; 值得别名\ntype str2 &#x3D; boolean | 0 | &#39;s&#39;\nlet q3: str2 &#x3D; false</code></pre>\n\n<h5 id=\"symbol和迭代器\"><a href=\"#symbol和迭代器\" class=\"headerlink\" title=\"symbol和迭代器\"></a>symbol和迭代器</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;*\nsymbol类型的值是通过Symbol构造函数创建的\n传递参数作为唯一标识只支持string和number类型\n用作对象属性的健\n使用symbol的值是不能通过循环拿到的\n比如 for in Object.keys getOwnPropertyNames JSON.stringify\n可以通过 Object.getOwnPropertySymbols Reflect.ownKeys拿到值\n*&#x2F;\nlet w1:symbol &#x3D; Symbol(&#39;dsa&#39;)\nlet sym:symbol &#x3D; Symbol()\nlet obj &#x3D; &#123;\n  [sym]: 546\n&#125;\n&#x2F;*\nSymbol.iterator迭代器 和生成器 for of\n大部分类型都支持迭代器比如 arr arguments set map 等这些可迭代类型\n通过next方法获得一次迭代结果值 直到获得undefined时迭代完成\n*&#x2F;\nlet w2:number[] &#x3D; [1,2,3,4,5]\nlet iterator:IterableIterator&lt;number&gt; &#x3D; w2[Symbol.iterator]()\nconsole.log(iterator.next())\nconsole.log(iterator.next())\nconsole.log(iterator.next())\nconsole.log(iterator.next())\nconsole.log(iterator.next())\nconsole.log(iterator.next())\ninterface Item &#123;\n  age: number,\n  name: string\n&#125;\nconst array: Array&lt;Item&gt; &#x3D; [ &#123;age: 123, name: &#39;sda&#39;&#125;, &#123;age: 404, name: &#39;qe&#39;&#125;]\ntype mapTypes &#x3D; string | number\nconst map:Map&lt;mapTypes, mapTypes&gt; &#x3D; new Map()\nmap.set(&#39;1&#39;,&quot;你好哇&quot;)\nmap.set(&#39;2&#39;,&quot;我很好&quot;)\nlet set:Set&lt;number&gt; &#x3D; new Set([1,2,3,2,3])\nconst gen &#x3D; (arg:any):void &#x3D;&gt; &#123;\n  let it:IterableIterator&lt;any&gt; &#x3D; arg[Symbol.iterator]()\n  let next:any &#x3D; &#123; done: false &#125;\n  while(!next.done)&#123;\n    next &#x3D; it.next()\n    if(!next.done)&#123;\n      console.log(next)\n    &#125;\n  &#125;\n&#125;\ngen(array)\ngen(map)\ngen(set)\n</code></pre>\n\n<h5 id=\"泛型字面量\"><a href=\"#泛型字面量\" class=\"headerlink\" title=\"泛型字面量\"></a>泛型字面量</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;*泛型字面量\n 语法 &lt;任意参数名&gt;\n 当使用时把参数的类型传递进去\n 调用时需要确定其类型\n*&#x2F;\nfunction Add1&lt;T&gt;(a:T,b:T):Array&lt;T&gt;&#123;\n    return [a,b]\n&#125;\nAdd1&lt;number&gt;(1,2)\nAdd1&lt;string&gt;(&quot;1&quot;,&quot;2&quot;)\n&#x2F;*\n不同的泛型参数名,只要在数量上和使用方式上能对应上就可以\n*&#x2F;\nfunction Add2&lt;T,U&gt;(a:T,b:U):Array&lt;T|U&gt;&#123;\n  return [a,b]\n&#125;\nAdd2&lt;Boolean,number&gt;(false,1)\n&#x2F;*\n泛型接口 在接口名字后面加个&lt;参数&gt;\n*&#x2F;\ninterface myInter&lt;T&gt;&#123;\n  (arg:T):T\n&#125;\nfunction Add3&lt;T&gt;(arg:T):T&#123;\n  return arg\n&#125;\nlet add3:myInter&lt;number&gt; &#x3D; Add3\nadd3(112)\n&#x2F;*\n对象字面量\n*&#x2F;\nlet foo: &#123;\n  &lt;T&gt;(arg:T): T\n&#125;\nfoo &#x3D; function &lt;T&gt;(arg:T):T&#123;\n  return arg\n&#125;\nfoo(789)\n&#x2F;*\n泛型约束\n通过接口继承的方式约定其必须要有length属性\n*&#x2F;\ninterface Len &#123;\n  length: number\n&#125;\nfunction Add4&lt;T extends Len&gt;(arg:T)&#123;\n  return arg.length\n&#125;\nAdd4&lt;string&gt;(&#39;1143&#39;)\n&#x2F;*\n使用keyof约束对象\n首先定义T类型并使用extends继承object类型的子类型\n然后使用keyof操作符获取T类型的所有健\n返回一个联合类型\n最后利用extends关键字约束k类型必须为keyof T联合类型的子类型\n*&#x2F;\nfunction Add5&lt;T,K extends keyof T&gt;(obj: T, key:K)&#123;\n  return obj[key]\n&#125;\n\nlet o &#x3D; &#123;a:1,b:2,c:3&#125;\nAdd5(o, &#39;a&#39;)\n&#x2F;*\n泛型类\n*&#x2F;\nclass Add6&lt;T&gt;&#123;\n  attr: T[] &#x3D; []\n  add(a:T):T[]&#123;\n    return [ a ]\n  &#125;\n&#125;\nlet add2 &#x3D; new Add6&lt;number&gt;()\nadd2.attr &#x3D; [1,2,4]\nadd2.add(789)\nlet add4 &#x3D; new Add6&lt;string&gt;()\nadd4.attr &#x3D; [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;]\nadd4.add(&#39;asac&#39;)</code></pre>\n\n<h5 id=\"声明文件declare\"><a href=\"#声明文件declare\" class=\"headerlink\" title=\"声明文件declare\"></a>声明文件declare</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;*\n当使用第三方库时需要引用对应的声明文件\n如果有一些第三方包没有声明文件可以自己定义\n*&#x2F;\ndeclare var 声明全局变量\ndeclare function 声明全局方法\ndeclare class 声明全局类\ndeclare enum 声明全局枚举类型\ndeclare namespace 声明全局对象\ninterface 和 type 声明全局类型\n&#x2F;&#x2F;&#x2F; &lt;reference &#x2F;&gt; 三斜线指令</code></pre>\n\n","feature":true,"text":"Typescript基础基础类型基本类型分为: Boolean Number String null undefined Symbol BigInt let a:boolean &#x3D; true &#x2F;&#x2F; 布尔型 let b:string &#x3D; &q...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"技术","slug":"技术","count":19,"path":"api/categories/技术.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":1,"path":"api/tags/TypeScript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Typescript%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">Typescript基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">基础类型</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#any%E5%92%8Cunknown\"><span class=\"toc-text\">any和unknown</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">接口和对象类型</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">数组类型</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95\"><span class=\"toc-text\">函数扩展</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">联合类型</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA\"><span class=\"toc-text\">类型推论</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#symbol%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8\"><span class=\"toc-text\">symbol和迭代器</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B%E5%AD%97%E9%9D%A2%E9%87%8F\"><span class=\"toc-text\">泛型字面量</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6declare\"><span class=\"toc-text\">声明文件declare</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"小提琴","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"我见青山多妩媚，料青山、见我应如是。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"递归树函数柯里化","uid":"c630e8b20885330b03b488ffd97cdd35","slug":"递归树函数柯里化","date":"2022-08-24T14:33:12.000Z","updated":"2022-08-24T14:33:53.798Z","comments":true,"path":"api/articles/递归树函数柯里化.json","keywords":null,"cover":"static\\img\\photo-1591693117893-7cbfc0a7ac69.jpg","text":"递归树函数柯里化&#x2F;* 模拟递归树 首先树要有一个唯一的根节点已经若干个子节点 子节点的pid要等于父节点的id,通过标识判断子节点 是否属于父节点 *&#x2F; const obj &#x3D; [ &#123; id: 1, pid: 0, name: &#39;主...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"技术","slug":"技术","count":19,"path":"api/categories/技术.json"}],"tags":[{"name":"ES6","slug":"ES6","count":8,"path":"api/tags/ES6.json"},{"name":"JavaScript","slug":"JavaScript","count":10,"path":"api/tags/JavaScript.json"}],"author":{"name":"小提琴","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"我见青山多妩媚，料青山、见我应如是。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}