{"title":"ReactHooks","uid":"316ea3df3f075543c59a5d1fe255bb06","slug":"ReactHooks","date":"2022-06-13T14:29:12.000Z","updated":"2022-06-13T14:30:19.309Z","comments":true,"path":"api/articles/ReactHooks.json","keywords":null,"cover":"static\\img\\photo-1591693117893-7cbfc0a7ac69.jpg","content":"<h2 id=\"ReactHooks\"><a href=\"#ReactHooks\" class=\"headerlink\" title=\"ReactHooks\"></a>ReactHooks</h2><p>hooks优点:</p>\n<ol>\n<li>高阶组件为了复用，导致代码层级复杂 </li>\n<li>生命周期的复杂 </li>\n<li>写成functional组件,无状态组件 ，因为需要状态，又改成了class,成本高</li>\n<li>不存在生命周期，所以不要把 Class Component 的生命周期概念搬过来试图对号入座</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; useState保存组件状态\nconst [ state, setstate] &#x3D; useState(initialState)</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; useEffect处理副作用\nuseEffect( () &#x3D;&gt; &#123;\n  return () &#x3D;&gt; &#123;&#125;\n&#125;,[依赖的状态;空数组表示不依赖])\n&#x2F;&#x2F; 案例\nlet id &#x3D; props.match.params.myid \nuseEffect(()&#x3D;&gt;&#123;    \naxios.get(&#96;&#x2F;articles&#x2F;$&#123;id&#125;&#96;).then(res &#x3D;&gt; &#123;        \nsettitle(res.data.title)        \nsetcontent(res.data.content)        \nsetcategory(res.data.category)   \n&#125;) &#125;,[id])\n&#x2F;*\n简单来说就是调用时机不同， useLayoutEffect 和原来 componentDidMount &amp; componentDidUpdate 一致，在 react完成DOM更新后马上同步调用的代码，会阻塞页面渲染。而 useEffect 是会在整个页面渲染完才会调用的 代码\n*&#x2F;\n&#x2F;*\n在实际使用时如果想避免页面抖动（在 useEffect 里修改DOM很有可能出现）的话，可以把需要操作DOM的代码 放在 useLayoutEffect 里。在这里做点dom操作，这些dom修改会和 react 做出的更改一起被一次性渲染到屏幕 上，只有一次回流、重绘的代价。\n*&#x2F;</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; useCallback记忆函数\n防止因为组件重新渲染，导致方法被重新创建 ，起到缓存作用; 只有第二个参数 变化了，才重新声明一次\nlet handleClick &#x3D; useCallback( () &#x3D;&gt; \n&#123;    \nconsole.log(name)  \n&#125;,[name])   \n&lt;button onClick&#x3D;&#123;()&#x3D;&gt;handleClick()&#125;&gt;hello&lt;&#x2F;button&gt;    \n&#x2F;&#x2F;只有name改变后， 这个函数才会重新声明一次，   \n&#x2F;&#x2F;如果传入空数组， 那么就是第一次创建后就被缓存， 如果name后期改变了,拿到的还是老的name。  \n&#x2F;&#x2F;如果不传第二个参数，每次都会重新声明一次，拿到的就是最新的name</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; useMemo 记忆组件\n&#x2F;&#x2F; useCallback 的功能完全可以由 useMemo 所取代\n&#x2F;&#x2F; 如果你想通过使用 useMemo 返回一个记忆函数也是完全可以的。\n&#x2F;* useMemo是针对一个函数，是否多次执行\nuseMemo主要用来解决使用React hooks产生的无用渲染的性能问题\n在方法函数，由于不能使用shouldComponentUpdate处理性能问题，react hooks新增了useMemo\n*&#x2F;\nlet richChild &#x3D; useMemo(() &#x3D;&gt; &#123;\n\t\t&#x2F;&#x2F;执行相应的函数\n\t\treturn getRichChild();\n\t&#125;, [props.name]);\n&#x2F;*\nuseCallback 常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。而 useMemo 更适合经过函数 计算得到一个确定的值，比如记忆组件\n*&#x2F;</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; useRef保存引用值\nmport React, &#123;useRef&#125; from &quot;react&quot;;\n\nfunction Ref ()&#123;\n    const box &#x3D; useRef()\n\n    return (\n        &lt;div&gt;\n            &lt;div ref&#x3D;&#123;box&#125;&gt;useRef&lt;&#x2F;div&gt;\n            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; console.log(box)&#125;&gt;+1&lt;&#x2F;button&gt;\n        &lt;&#x2F;div&gt;\n    )\n&#125;\nexport default Ref;\n&#x2F;*\n 当我们需要获取元素对象的时候， 首先引入useRef， 其次调用useRef（）方法接收它的返回值，我们需要获取那个DOM元素就在那个DOM元素上进行绑定，通过ref属性将useRef的返回值绑定到元素身上，这样useRef的返回值，通过useRef返回一个对象，对象内部有个current属性，这个属性就对应着我们需要的元素对象；\n*&#x2F;\nimport React, &#123;useRef, useEffect, useState&#125; from &quot;react&quot;;\n\nfunction Ref ()&#123;\n    let timerId &#x3D; useRef()\n    const [count, setCount] &#x3D; useState(0)\n    useEffect(() &#x3D;&gt; &#123;\n        timerId.current &#x3D; setInterval(() &#x3D;&gt; &#123;\n            setCount(count &#x3D;&gt; count + 1)\n        &#125;, 1000)\n    &#125;, [])\n    const stop &#x3D; () &#x3D;&gt; &#123;\n        console.log(timerId)\n        clearInterval(timerId.current)\n    &#125;\n    return (\n        &lt;div&gt;\n            &lt;div&gt;&#123;count&#125;&lt;&#x2F;div&gt;\n            &lt;button onClick&#x3D;&#123;stop&#125;&gt;停止&lt;&#x2F;button&gt;\n        &lt;&#x2F;div&gt;\n    )\n&#125;\nexport default Ref;</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;useReducer和useContext减少组件层级\nimport React, &#123; useContext, useReducer &#125; from &#39;react&#39;\n\nconst intialState &#x3D; &#123;\n  a: 1,\n  b: 1\n&#125;\nconst reducer &#x3D; (preState, action) &#x3D;&gt; &#123;\n  let newState &#x3D; &#123;...preState&#125;\n  switch(action.type)&#123;\n    case &#39;add1&#39;:\n        newState.a &#x3D; action.value\n        return newState\n    case &#39;add2&#39;:\n        newState.b++\n        return newState\n    default:\n        return preState\n  &#125;\n&#125;\nconst GlobalContext &#x3D; React.createContext()\nexport default function App() &#123;\n  const [state, dispatch] &#x3D; useReducer(reducer,intialState)\n  return (\n    &lt;GlobalContext.Provider value&#x3D;&#123;\n      &#123;\n        state,\n        dispatch\n      &#125; \n    &#125;&gt;\n    &lt;div&gt;\n      &lt;Chilren01&gt;\n        \n      &lt;&#x2F;Chilren01&gt;\n      &lt;Chilren02 &gt;\n        \n      &lt;&#x2F;Chilren02&gt;\n      &lt;Chilren03 &gt;\n\n      &lt;&#x2F;Chilren03&gt;\n    &lt;&#x2F;div&gt;\n    &lt;&#x2F;GlobalContext.Provider&gt;\n  )\n&#125;\nfunction Chilren01()&#123;\n  const &#123; dispatch &#125; &#x3D; useContext(GlobalContext)\n  return (\n    &lt;div&gt;\n        &lt;button onClick&#x3D;&#123;\n           () &#x3D;&gt; &#123;\n            dispatch(&#123;\n                type: &#39;add1&#39;,\n                value: 222222\n              &#125;)\n           &#125;\n        &#125;&gt;改变a&lt;&#x2F;button&gt;\n        &lt;button \n        onClick&#x3D;&#123;\n           () &#x3D;&gt; &#123;\n            dispatch(&#123;\n                type: &#39;add2&#39;\n              &#125;)\n           &#125;\n            &#125;&gt;改变b&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  )\n&#125;\nfunction Chilren02()&#123;\n    const &#123; state &#125; &#x3D; useContext(GlobalContext)\n  return (\n    &lt;div style&#x3D;&#123;&#123;background: &#39;gray&#39;&#125;&#125;&gt;\n        &lt;span&gt;\n            &#123;state.a&#125;\n        &lt;&#x2F;span&gt;\n    &lt;&#x2F;div&gt;\n  )\n&#125;\nfunction Chilren03()&#123;\n    const &#123; state &#125; &#x3D; useContext(GlobalContext)\n  return (\n    &lt;div style&#x3D;&#123;&#123;background: &#39;pink&#39;&#125;&#125;&gt;\n      &lt;span&gt;\n        &#123;state.b&#125;\n      &lt;&#x2F;span&gt;\n    &lt;&#x2F;div&gt;\n  )\n&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>自定义hooks</p>\n<p>当我们想在两个函数之间共享逻辑时，我们会把它提取到第三个函数中。<br>必须以“use”开头吗？必须如此。这个约定非常重要。不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了 Hook 的规则</p></blockquote>\n","text":"ReactHookshooks优点: 高阶组件为了复用，导致代码层级复杂 生命周期的复杂 写成functional组件,无状态组件 ，因为需要状态，又改成了class,成本高 不存在生命周期，所以不要把 Class Component 的生命周期概念搬过来试图对号入座 &#x2F...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[{"name":"技术","slug":"技术","count":20,"path":"api/categories/技术.json"}],"tags":[{"name":"ES6","slug":"ES6","count":8,"path":"api/tags/ES6.json"},{"name":"JavaScript","slug":"JavaScript","count":10,"path":"api/tags/JavaScript.json"},{"name":"React","slug":"React","count":1,"path":"api/tags/React.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ReactHooks\"><span class=\"toc-text\">ReactHooks</span></a></li></ol>","author":{"name":"小提琴","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"我见青山多妩媚，料青山、见我应如是。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"ui库ui-button按钮","uid":"32a3ee3e88f21c8f7c84d017e1289b77","slug":"自定义封装ui-button按钮","date":"2022-06-27T03:48:12.000Z","updated":"2022-06-27T15:52:53.179Z","comments":true,"path":"api/articles/自定义封装ui-button按钮.json","keywords":null,"cover":"static\\img\\photo-1571361656693-d7602246ce3c.jpg","text":"自定义封装ui-button按钮知识点 组件通信 组件插槽 props校验 参数 参数名 参数描述 参数类型 默认值 type 按钮类型(info,success,primary,waring,danger) strign default plain 是否朴素按钮 boolean...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[{"name":"ui库","slug":"ui库","count":5,"path":"api/categories/ui库.json"}],"tags":[{"name":"ui库","slug":"ui库","count":5,"path":"api/tags/ui库.json"}],"author":{"name":"小提琴","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"我见青山多妩媚，料青山、见我应如是。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"发布订阅模式","uid":"e9ee661d319ac0e21c172e3d1f135c82","slug":"发布订阅模式","date":"2022-06-13T14:29:12.000Z","updated":"2022-06-13T14:35:49.282Z","comments":true,"path":"api/articles/发布订阅模式.json","keywords":null,"cover":"static\\img\\photo-1591693117893-7cbfc0a7ac69.jpg","text":"发布订阅模式什么是发布消息订阅模式? 基于一个事件通道 希望接收通知的对象A通过自定义事件订阅主题 被激活事件的对象B通过发布主题事件的方式通知各个订阅该主题的A对象 class Observer &#123; constructor()&#123; &#x2F;&#x2F; 事...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"技术","slug":"技术","count":20,"path":"api/categories/技术.json"}],"tags":[{"name":"ES6","slug":"ES6","count":8,"path":"api/tags/ES6.json"},{"name":"JavaScript","slug":"JavaScript","count":10,"path":"api/tags/JavaScript.json"}],"author":{"name":"小提琴","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"我见青山多妩媚，料青山、见我应如是。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}