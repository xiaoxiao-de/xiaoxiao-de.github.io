{"title":"VueRouter","uid":"5d40e7fe0c283422ee253e93aca4d4aa","slug":"VueRouter路由","date":"2022-05-16T12:46:25.000Z","updated":"2022-06-05T15:53:30.479Z","comments":true,"path":"api/articles/VueRouter路由.json","keywords":null,"cover":"static\\img\\20200401220041648.gif","content":"<h3 id=\"VueRouter路由\"><a href=\"#VueRouter路由\" class=\"headerlink\" title=\"VueRouter路由\"></a>VueRouter路由</h3><p>vue 的一个插件库，专门用来实现SPA 应用</p>\n<p> vue2中使用的是<a href=\"mailto:&#118;&#x75;&#101;&#x2d;&#x72;&#x6f;&#117;&#x74;&#101;&#114;&#64;&#51;&#46;&#x78;\">&#118;&#x75;&#101;&#x2d;&#x72;&#x6f;&#117;&#x74;&#101;&#114;&#64;&#51;&#46;&#x78;</a></p>\n<p> vue3中使用的是<a href=\"mailto:&#x76;&#x75;&#x65;&#x2d;&#114;&#111;&#x75;&#x74;&#x65;&#x72;&#64;&#52;&#x2e;&#x78;\">&#x76;&#x75;&#x65;&#x2d;&#114;&#111;&#x75;&#x74;&#x65;&#x72;&#64;&#52;&#x2e;&#x78;</a></p>\n<h5 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h5><p>一个路由就是一组映射关系</p>\n<p>key为路径,value就是一个component或者一个方法</p>\n<p>路由分为前端路由和后端路由</p>\n<p>后端路由是一个方法服务器接收到一个请求时，根据请求路径找到匹配的函数来处理请求，返回响应数据</p>\n<p>前端路由:value 是 component，用于展示页面内容，当浏览器的路径改变时，对应的组件就会显示</p>\n<p>路由下载</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; vue2\nnpm i vue-router\n&#x2F;&#x2F; vue3\nnpm i vue-router@next</code></pre>\n\n<p>在vue2中</p>\n<ol>\n<li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息</li>\n<li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到</li>\n<li>子路由跳转：<code>&lt;router-link to=&quot;/a/b&quot;&gt;a&lt;/router-link&gt;</code></li>\n<li>要写（&#x2F;）路径来明确子路由地址</li>\n<li>路由to可以省略&#x2F;默认Vue-router给加上了</li>\n<li>路由跳转可以携带参数一般存放在query或params</li>\n<li>路由的命名可以简化路由的跳转及一些操作</li>\n<li>路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import Vue from &#39;vue&#39; &#x2F;&#x2F; 引入vue\nimport Router from &#39;vue-router&#39; &#x2F;&#x2F; 引入vueRouter\n&#x2F;&#x2F;创建一个路由 配置路由\n&#x2F;&#x2F; 声明一个数组 \nconst routes &#x3D; [\n  &#123;\n    path: &#39;&#x2F;&#39;,\n    name: &#39;Home&#39;,\n    component: () &#x3D;&gt; import(&#39;..&#x2F;view&#x2F;Home.vue&#39;)\n  &#125;\n]\n&#x2F;&#x2F; 挂载到vue上\nVue.use(Router)\n&#x2F;&#x2F; 声明一个路由器并暴露出去\nconst router &#x3D; new Router(&#123;\n  base: &#39;&#x2F;&#39;, &#x2F;&#x2F; 应用的基本路径\n  mode: &#39;&#39;  &#x2F;&#x2F; 路由模式 hash模式 history模式 abstract模式\n  routes\n&#125;)\n\nexport default router</code></pre>\n\n<p>在vue3中</p>\n<p>vue3中使用组合式API(Composition API)</p>\n<p>vue3不在使用newRouter()创建实例而是使用createRouter方法</p>\n<p>路由模式也是分别通过 createWebHistory,createWebHashHistory,createMemoryHistory传递base来创建 </p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 使用组合式api方式引入使用的对象方法而不是引入整个包\nimport &#123; createRouter, createWebHistory &#125; from &#39;vue-router&#39;\n\n&#x2F;&#x2F;创建一个路由 配置路由\n&#x2F;&#x2F; 声明一个数组 \nconst routes &#x3D; [\n  &#123;\n    path: &#39;&#x2F;&#39;,\n    name: &#39;Home&#39;,\n   component: () &#x3D;&gt; import(&#39;..&#x2F;view&#x2F;Home.vue&#39;)\n  &#125;,\n]\n&#x2F;&#x2F; 声明一个路由器并暴露出去\nconst router &#x3D; createRouter(&#123;\n  &#x2F;&#x2F; 创建了一个history设置了基本路径\n  history: createWebHistory(process.env.BASE_URL), \n  routes\n&#125;)\n\nexport default router</code></pre>\n\n<h5 id=\"vue2中路由跳转传参\"><a href=\"#vue2中路由跳转传参\" class=\"headerlink\" title=\"vue2中路由跳转传参\"></a>vue2中路由跳转传参</h5><p>query</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">!-- 跳转并携带query参数，to的字符串写法 --&gt;\n&lt;router-link :to&#x3D;&quot;&#x2F;home&#x2F;message&#x2F;detail?id&#x3D;666&amp;title&#x3D;你好&quot;&gt;跳转&lt;&#x2F;router-link&gt;\n\t\t\t\t\n&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;\n&lt;router-link :to&#x3D;&quot;&#123;\n\tpath:&#39;&#x2F;home&#x2F;message&#x2F;detail&#39;,\n\tquery:&#123;\n\t\tid:666,\n        title:&#39;你好&#39;\n\t&#125;\n&#125;&quot;&gt;跳转&lt;&#x2F;router-link&gt;\n\n\n&#x2F;&#x2F; 接收参数\n$route.query.id\n$route.query.title</code></pre>\n\n<p>params</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 传递参数\n                &lt;!-- 跳转路由并携带params参数，to的对象写法 --&gt;\n                &lt;router-link :to&#x3D;&quot;&#123;\n                    name:&#39;xiangqing&#39;,\n                    params:&#123;\n                        id:m.id,\n                        title:m.title\n                    &#125;\n                &#125;&quot;&gt;\n                    &#123;&#123;m.title&#125;&#125;\n                &lt;&#x2F;router-link&gt;\n                \n               \n &#x2F;&#x2F; 接收参数\n$route.params.id\n$route.params.title</code></pre>\n\n<h5 id=\"路由跳转的replace方法\"><a href=\"#路由跳转的replace方法\" class=\"headerlink\" title=\"路由跳转的replace方法\"></a>路由跳转的replace方法</h5><p>vue2中</p>\n<ul>\n<li><p>控制路由跳转时操作浏览器历史记录的模式</p>\n</li>\n<li><p>浏览器的历史记录有两种写入方式：<code>push</code>和<code>replace</code>，其中<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code>方式</p>\n</li>\n<li><p>开启<code>replace</code>模式：<code>&lt;router-link replace ...&gt;News&lt;/router-link&gt;</code></p>\n</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; vue2\nthis.$router.push() &#x2F;&#x2F; 跳转路由追加记录\nthis.$router.replace() &#x2F;&#x2F; 跳转路由替换当前记录不追加记录\nthis.$router.forward() &#x2F;&#x2F;前进\nthis.$router.back() &#x2F;&#x2F;后退\nthis.$router.go() &#x2F;&#x2F;可前进也可后退</code></pre>\n\n<p>vue3中</p>\n<p>由于vue3的setup方法没有this,所有不能使用this.$router获取路由对象</p>\n<p>vue3中使用useRouter方法进行跳转</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import &#123; useRouter &#125; fom vue-router\n\nexport default &#123;\n  setup() &#123;\n    const router &#x3D; useRouter() &#x2F;&#x2F; 声明一个路由\n    router.push() &#x2F;&#x2F; 跳转路由追加记录\n    router.replace() &#x2F;&#x2F; 跳转路由替换当前记录不追加记录\n  &#125;\n&#125;</code></pre>\n\n\n\n<h5 id=\"缓存路由组件\"><a href=\"#缓存路由组件\" class=\"headerlink\" title=\"缓存路由组件\"></a>缓存路由组件</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;keep-alive include&#x3D;&quot;&quot;&gt;  &#x2F;&#x2F;include中写想要缓存的组件名，不写表示全部缓存\n\t\t\t\t&lt;router-view&gt;&lt;&#x2F;router-view&gt;\n&lt;&#x2F;keep-alive&gt;</code></pre>\n\n<p>让不展示的路由组件保持挂载，不被销毁</p>\n<p><code>activated</code>和<code>deactivated</code>是路由组件所独有的两个钩子，用于捕获路由组件的激活状态</p>\n<ol>\n<li><code>activated</code>路由组件被激活时触发</li>\n<li>deactivated&#96;路由组件失活时触发</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">activated()&#123;\n           console.log(&#39;News组件被激活了&#39;)\n           this.timer &#x3D; setInterval(() &#x3D;&gt; &#123;\n               this.opacity -&#x3D; 0.01\n               if(this.opacity &lt;&#x3D; 0) this.opacity &#x3D; 1\n           &#125;,16)\n       &#125;,\n       deactivated()&#123;\n           console.log(&#39;News组件失活了&#39;)\n           clearInterval(this.timer)\n       &#125;</code></pre>\n\n<h5 id=\"全局路由守卫\"><a href=\"#全局路由守卫\" class=\"headerlink\" title=\"全局路由守卫\"></a>全局路由守卫</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;全局前置路由守卫————初始化的时候、每次路由切换之前被调用\nrouter.beforeEach((to,from,next) &#x3D;&gt; &#123;\n    console.log(&#39;前置路由守卫&#39;,to,from)\n    if(to.meta.isAuth)&#123;\n        if(localStorage.getItem(&#39;school&#39;)&#x3D;&#x3D;&#x3D;&#39;atguigu&#39;)&#123;\n            next()\n        &#125;else&#123;\n            alert(&#39;学校名不对，无权限查看！&#39;)\n        &#125;\n    &#125;else&#123;\n        next()\n    &#125;\n&#125;)\n\n&#x2F;&#x2F;全局后置路由守卫————初始化的时候被调用、每次路由切换之后被调用\nrouter.afterEach((to,from)&#x3D;&gt;&#123;\n\tconsole.log(&#39;后置路由守卫&#39;,to,from)\n\tdocument.title &#x3D; to.meta.title || &#39;硅谷系统&#39;\n&#125;)\n&#x2F;&#x2F;独享守卫，特定路由切换之后被调用\n                    beforeEnter(to,from,next)&#123;\n                        console.log(&#39;独享路由守卫&#39;,to,from)\n                        if(localStorage.getItem(&#39;school&#39;) &#x3D;&#x3D;&#x3D; &#39;atguigu&#39;)&#123;\n                            next()\n                        &#125;else&#123;\n                            alert(&#39;暂无权限查看&#39;)\n                        &#125;\n                    &#125;\n &#x2F;&#x2F;通过路由规则，离开该组件时被调用\n        beforeRouteEnter (to, from, next) &#123;\n            console.log(&#39;About--beforeRouteEnter&#39;,to,from)\n            if(localStorage.getItem(&#39;school&#39;)&#x3D;&#x3D;&#x3D;&#39;atguigu&#39;)&#123;\n                next()\n            &#125;else&#123;\n                alert(&#39;学校名不对，无权限查看！&#39;)\n            &#125;\n        &#125;,\n        &#x2F;&#x2F;通过路由规则，离开该组件时被调用\n        beforeRouteLeave (to, from, next) &#123;\n            console.log(&#39;About--beforeRouteLeave&#39;,to,from)\n            next()\n        &#125;</code></pre>\n\n<p>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值</p>\n<p>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器</p>\n<p>hash模式：</p>\n<p>地址中永远带着#号，不美观<br>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法<br>兼容性较好<br>history模式：</p>\n<p>地址干净，美观<br>兼容性和hash模式相比略差<br>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题</p>\n<h5 id=\"默认路由地址重定向\"><a href=\"#默认路由地址重定向\" class=\"headerlink\" title=\"默认路由地址重定向\"></a>默认路由地址重定向</h5>","feature":true,"text":"VueRouter路由vue 的一个插件库，专门用来实现SPA 应用 vue2中使用的是&#118;&#x75;&#101;&#x2d;&#x72;&#x6f;&#117;&#x74;&#101;&#114;&#64;&#51;&#46;&#x78; vue3中使用的是&#x76...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"技术","slug":"技术","count":6,"path":"api/categories/技术.json"}],"tags":[{"name":"Vue","slug":"Vue","count":3,"path":"api/tags/Vue.json"},{"name":"JavaScript","slug":"JavaScript","count":3,"path":"api/tags/JavaScript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#VueRouter%E8%B7%AF%E7%94%B1\"><span class=\"toc-text\">VueRouter路由</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%B7%AF%E7%94%B1\"><span class=\"toc-text\">路由</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#vue2%E4%B8%AD%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E4%BC%A0%E5%8F%82\"><span class=\"toc-text\">vue2中路由跳转传参</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E7%9A%84replace%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">路由跳转的replace方法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%AD%98%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">缓存路由组件</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%85%A8%E5%B1%80%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB\"><span class=\"toc-text\">全局路由守卫</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1%E5%9C%B0%E5%9D%80%E9%87%8D%E5%AE%9A%E5%90%91\"><span class=\"toc-text\">默认路由地址重定向</span></a></li></ol></li></ol></li></ol>","author":{"name":"小提琴","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"我见青山多妩媚，料青山、见我应如是。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Minxins","uid":"fa9186e3fcd1aa3f18e4e09eef185770","slug":"Mixins","date":"2022-06-06T13:30:11.000Z","updated":"2022-06-06T14:49:31.239Z","comments":true,"path":"api/articles/Mixins.json","keywords":null,"cover":"static\\img\\photo-1496449903678-68ddcb189a24.jpg","text":"Mixins分发Vue组件复用功能 mixins是一个js对象,它可以包含我们组件中script的任意选项 类如: data components methods created computed 等等 将组件中共用功能以对象的方式传入mixins选项 当组件使用mixins对象...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"技术","slug":"技术","count":6,"path":"api/categories/技术.json"}],"tags":[{"name":"Vue","slug":"Vue","count":3,"path":"api/tags/Vue.json"},{"name":"JavaScirpt","slug":"JavaScirpt","count":1,"path":"api/tags/JavaScirpt.json"}],"author":{"name":"小提琴","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"我见青山多妩媚，料青山、见我应如是。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Promise","uid":"b468f3c3ac71ea2b71e5a5059fe38476","slug":"Promise的理解和使用","date":"2022-05-15T12:46:25.000Z","updated":"2022-06-04T10:59:15.720Z","comments":true,"path":"api/articles/Promise的理解和使用.json","keywords":null,"cover":"static\\img\\photo-1571361656693-d7602246ce3c.jpg","text":"Promise的理解和使用 promise是一门新的技术(es6规范) promise是异步编程的新解决方案 从语法上来说:promise是一个构造函数 从功能上来说:promise对象用来封装异步操作并可以获取成功和失败的结果 promise: 启动异步任务 &#x3D;&gt...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"技术","slug":"技术","count":6,"path":"api/categories/技术.json"}],"tags":[{"name":"ES6","slug":"ES6","count":1,"path":"api/tags/ES6.json"},{"name":"JavaScript","slug":"JavaScript","count":3,"path":"api/tags/JavaScript.json"}],"author":{"name":"小提琴","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"我见青山多妩媚，料青山、见我应如是。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}