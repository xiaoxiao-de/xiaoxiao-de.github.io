[{"id":"5d40e7fe0c283422ee253e93aca4d4aa","title":"VueRouter","content":"VueRouter路由vue 的一个插件库，专门用来实现SPA 应用\n路由一个路由就是一组映射关系\nkey为路径,value就是一个component或者一个方法\n路由分为前端路由和后端路由\n后端路由是一个方法服务器接收到一个请求时，根据请求路径找到匹配的函数来处理请求，返回响应数据\n前端路由:value 是 component，用于展示页面内容，当浏览器的路径改变时，对应的组件就会显示\n路由下载\nnpm i vue-router\n\n\n每个组件都有自己的$route属性，里面存储着自己的路由信息\n\n整个应用只有一个router，可以通过组件的$router属性获取到\n\n子路由跳转：&lt;router-link to=&quot;/a/b&quot;&gt;a&lt;/router-link&gt;\n\n要写（&#x2F;）路径来明确子路由地址\n\n路由to可以省略&#x2F;默认Vue-router给加上了\n\n路由跳转可以携带参数一般存放在query或params\n\n路由的命名可以简化路由的跳转及一些操作\n\n路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置\n\n\n传递参数query\n!-- 跳转并携带query参数，to的字符串写法 --&gt;\n&lt;router-link :to&#x3D;&quot;&#x2F;home&#x2F;message&#x2F;detail?id&#x3D;666&amp;title&#x3D;你好&quot;&gt;跳转&lt;&#x2F;router-link&gt;\n\t\t\t\t\n&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;\n&lt;router-link :to&#x3D;&quot;&#123;\n\tpath:&#39;&#x2F;home&#x2F;message&#x2F;detail&#39;,\n\tquery:&#123;\n\t\tid:666,\n        title:&#39;你好&#39;\n\t&#125;\n&#125;&quot;&gt;跳转&lt;&#x2F;router-link&gt;\n\n\n&#x2F;&#x2F; 接收参数\n$route.query.id\n$route.query.title\n\nparams\n&#x2F;&#x2F; 传递参数\n                &lt;!-- 跳转路由并携带params参数，to的对象写法 --&gt;\n                &lt;router-link :to&#x3D;&quot;&#123;\n                    name:&#39;xiangqing&#39;,\n                    params:&#123;\n                        id:m.id,\n                        title:m.title\n                    &#125;\n                &#125;&quot;&gt;\n                    &#123;&#123;m.title&#125;&#125;\n                &lt;&#x2F;router-link&gt;\n                \n               \n &#x2F;&#x2F; 接收参数\n$route.params.id\n$route.params.title\n\n路由跳转的replace方法控制路由跳转时操作浏览器历史记录的模式\n浏览器的历史记录有两种写入方式：push和replace，其中push是追加历史记录，replace是替换当前记录。路由跳转时候默认为push方式\n开启replace模式：&lt;router-link replace ...&gt;News&lt;/router-link&gt;\nthis.$router.forward() &#x2F;&#x2F;前进\nthis.$router.back() &#x2F;&#x2F;后退\nthis.$router.go() &#x2F;&#x2F;可前进也可后退\n\n缓存路由组件&lt;keep-alive include&#x3D;&quot;&quot;&gt;  &#x2F;&#x2F;include中写想要缓存的组件名，不写表示全部缓存\n\t\t\t\t&lt;router-view&gt;&lt;&#x2F;router-view&gt;\n&lt;&#x2F;keep-alive&gt;\n\n让不展示的路由组件保持挂载，不被销毁\nactivated和deactivated是路由组件所独有的两个钩子，用于捕获路由组件的激活状态\n\nactivated路由组件被激活时触发\ndeactivated&#96;路由组件失活时触发\n\nactivated()&#123;\n           console.log(&#39;News组件被激活了&#39;)\n           this.timer &#x3D; setInterval(() &#x3D;&gt; &#123;\n               this.opacity -&#x3D; 0.01\n               if(this.opacity &lt;&#x3D; 0) this.opacity &#x3D; 1\n           &#125;,16)\n       &#125;,\n       deactivated()&#123;\n           console.log(&#39;News组件失活了&#39;)\n           clearInterval(this.timer)\n       &#125;\n\n全局路由守卫&#x2F;&#x2F;全局前置路由守卫————初始化的时候、每次路由切换之前被调用\nrouter.beforeEach((to,from,next) &#x3D;&gt; &#123;\n    console.log(&#39;前置路由守卫&#39;,to,from)\n    if(to.meta.isAuth)&#123;\n        if(localStorage.getItem(&#39;school&#39;)&#x3D;&#x3D;&#x3D;&#39;atguigu&#39;)&#123;\n            next()\n        &#125;else&#123;\n            alert(&#39;学校名不对，无权限查看！&#39;)\n        &#125;\n    &#125;else&#123;\n        next()\n    &#125;\n&#125;)\n\n&#x2F;&#x2F;全局后置路由守卫————初始化的时候被调用、每次路由切换之后被调用\nrouter.afterEach((to,from)&#x3D;&gt;&#123;\n\tconsole.log(&#39;后置路由守卫&#39;,to,from)\n\tdocument.title &#x3D; to.meta.title || &#39;硅谷系统&#39;\n&#125;)\n&#x2F;&#x2F;独享守卫，特定路由切换之后被调用\n                    beforeEnter(to,from,next)&#123;\n                        console.log(&#39;独享路由守卫&#39;,to,from)\n                        if(localStorage.getItem(&#39;school&#39;) &#x3D;&#x3D;&#x3D; &#39;atguigu&#39;)&#123;\n                            next()\n                        &#125;else&#123;\n                            alert(&#39;暂无权限查看&#39;)\n                        &#125;\n                    &#125;\n &#x2F;&#x2F;通过路由规则，离开该组件时被调用\n        beforeRouteEnter (to, from, next) &#123;\n            console.log(&#39;About--beforeRouteEnter&#39;,to,from)\n            if(localStorage.getItem(&#39;school&#39;)&#x3D;&#x3D;&#x3D;&#39;atguigu&#39;)&#123;\n                next()\n            &#125;else&#123;\n                alert(&#39;学校名不对，无权限查看！&#39;)\n            &#125;\n        &#125;,\n        &#x2F;&#x2F;通过路由规则，离开该组件时被调用\n        beforeRouteLeave (to, from, next) &#123;\n            console.log(&#39;About--beforeRouteLeave&#39;,to,from)\n            next()\n        &#125;\n\n对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值\nhash值不会包含在 HTTP 请求中，即：hash值不会带给服务器\nhash模式：\n地址中永远带着#号，不美观若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法兼容性较好history模式：\n地址干净，美观兼容性和hash模式相比略差应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题\n默认路由地址重定向","slug":"VueRouter路由","date":"2022-05-16T12:46:25.000Z","categories_index":"技术","tags_index":"JavaScript,Vue","author_index":"小提琴"},{"id":"e5c9682f958fbae18070afcafeff3ba8","title":"git命令","content":"安装完git之后第一件是就是设置自己的用户名和邮箱地址git config --global user.name “用户名&quot;\ngit config --global user.email &quot;邮箱&quot;\n\n\n如果是使用了–global选项,那么命令只需要运行一次,即可用户生效\n配置完用户名和邮箱后会被写入到c盘的用户文件夹的.gitcongih文件中可以自行查看\n\ngit快速查看全局配置信息查看所有配置 git config --list --global\n指定查看配置项 git config user.name 或 user.email\n\n获取帮助信息git help config 或 git config -h\n\n初始化git仓库git init\n\n\n输入命令后会创建一个名.git的隐藏目录,\n这个.git目录就是当前项目的git仓库\n里面包含了初始化必要文件\n\n查看文件状态的命令git status 或 加s表示精简\n\n一次性将文件加入暂存区的命令git add . 或 加入暂存区 git add &#39;文件名&#39;\n\n将暂存区的文件提交到git厂库命令git commit  -m “提交消息”\n\n克隆远程仓库git clone 远程仓库地址\n\n如果需要从暂存去中移除对应大的文件使用git reset HEAD &quot;移除文件”\n\n跳过使用暂存区域 直接跳过暂存区,将工作区中的修改直接提交到git仓库git commit -a -m “描述消息&quot;\n\n从工作区和git仓库移除文件git rm -f &quot;文件名&quot;   &#x2F;&#x2F; 只删除git仓库  git rm --cached &quot;文件名&quot;\n\n查看提交历史git log\n\n回退到指定版本在一行上展示所有的提交历史git log --pretty&#x3D;online\n\n根据指定的提交ID回退指定版本git reset --hard &lt;CommitID&gt;\n\n再次根据最新的提交ID,跳转到最新的版本git reset --hard &lt;CommitID&gt;\n\n快速生成SSHkey—-远程仓库配置使用ssh-keygen -t rsa -b 4096 -C &quot;邮箱&quot;\n\n\n会在c盘用户文件夹.ssh目录生成id_rsa和id_rsa.pub\n使用记事本打开id_rsa.pub文件,复制里面的文本内容\n在浏览器中登入github 点击头像-&gt; settings(设置)-&gt;进行秘钥配置\n将id_rsa.pub 文件中的内容 粘贴到key对应的文本框中\n填写一个名称用来标识key\n\n检测sshkey是否配置成功ssh -T git@github.com\n\n上述命令执行成功后,可能会看到提示消息 输入yes即可\n查看分支git branch *带表当前所在分支\n\n创建分支git branch 分支名称 创建完分支后当前还是在主分支\n\n切换分支git  checkout 分支名称\n\n快速创建一个分支 并立即切换到新分支git checkout -b 分支名称\n\n合并分支 首先切换到主分支 在主分支上使用git merge 分支名称\n\n删除分支git branch -d 分支名称\n\n遇到冲突时的分支合并如果在两个不同的分支中,对同一个文件进行了不同的修改,git就没法干净的合并它们此时需要手动解决冲突,打开包含冲突的文件\ngit add .\ngit commit -m &quot;&quot;\n\n将本地分支推送到远程仓库,第一次将本地分支推送到远程仓库需要使用git push -u 远程仓库名字 本地分支名称：远程分支名称\n实际案例:\ngit push -u origin payment:pay\n\n第一次推送分支需要带-u参数,此后可以直接使用git push推送代码到分支此后可以直接使用git push 推送代码到远程分支\n查看远程仓库分支列表git remote show &#39;远程仓库名称&#39;\n\n跟踪分支 从远程仓库中 把远程分支下载到本地仓库git checkout -b 本地分支名称 远程仓库名称&#x2F;远程分支名称\n示例: git checkout -b payment origin&#x2F;pay\n\n查看远程分支最新代码下载到本地对应文件中可以使用git pull\n\n删除远程分支git push &#39;远程仓库名称(origin)&#39; --delete &#39;远程分支名称&#39;\n\n查看本地密钥cat ~&#x2F;.ssh&#x2F;id_rsa.pub\n\n已有账号创建私钥ssh-keygen -t rsa -C&quot;邮箱&quot;\n\ngit上拉取指定分支git clone -b 分支名 &#39;克隆地址&#39;\n\n","slug":"git基础","date":"2022-05-15T12:46:25.000Z","categories_index":"技术","tags_index":"GIT","author_index":"小提琴"},{"id":"b468f3c3ac71ea2b71e5a5059fe38476","title":"Promise","content":"Promise的理解和使用\npromise是一门新的技术(es6规范)\npromise是异步编程的新解决方案\n从语法上来说:promise是一个构造函数\n从功能上来说:promise对象用来封装异步操作并可以获取成功和失败的结果\npromise: 启动异步任务 &#x3D;&gt; 返回promise对象 &#x3D;&gt; 给promise对象绑定回调函数\n\npromise的优点支持链式调用,可以解决回调地狱问题\n\n\n\n\n\n\n\n\n\n什么是回调地狱？\n回调函数嵌套调用,外部回调函数异步执行的结果是嵌套的回调执行条件\n\n\n\n\n\n\n\n\n\n回调地狱的缺点？\n不便于阅读\n不便于异常处理\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;\n  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n  &lt;title&gt;Document&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  &lt;div class&#x3D;&quot;container&quot;&gt;\n    &lt;button class&#x3D;&quot;btn&quot; id&#x3D;&quot;btn&quot;&gt;点击抽奖&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;script&gt;\n  function rand(m,n) &#123;\n    return Math.ceil(Math.random()*(n-m+1)) + m+1\n  &#125;\n  let btn &#x3D;  document.querySelector(&quot;#btn&quot;)\n  btn.addEventListener(&#39;click&#39;,function()&#123;\n    &#x2F;&#x2F; 原生回调形式\n    &#x2F;&#x2F; setTimeout(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F;   let n &#x3D; rand(1,100)\n    &#x2F;&#x2F;   if(n &lt;&#x3D; 30) &#123;\n    &#x2F;&#x2F;     console.log(n)\n    &#x2F;&#x2F;     alert(&quot;恭喜中奖&quot;)\n    &#x2F;&#x2F;   &#125; else &#123;\n    &#x2F;&#x2F;     console.log(n)\n    &#x2F;&#x2F;     alert(&quot;谢谢惠顾&quot;)\n    &#x2F;&#x2F;   &#125;\n    &#x2F;&#x2F; &#125;,2000)\n    &#x2F;&#x2F; promise形式 promise有两个参数 resolve 返回成功操作\n    &#x2F;&#x2F; reject 表示失败操作  它可以包裹异步操作并对其进行封装\n    let p &#x3D;  new Promise((resolve, reject) &#x3D;&gt; &#123;\n      setTimeout(() &#x3D;&gt; &#123;\n      let n &#x3D; rand(1,100)\n      if(n &lt;&#x3D; 30) &#123;\n        console.log(n)\n        resolve() &#x2F;&#x2F; 将promise对象的状态设置为成功\n      &#125; else &#123;\n        console.log(n)\n        reject() &#x2F;&#x2F; 将promise对象的状态设置为失败\n      &#125;\n    &#125;,1000)\n    &#125;) \n    p.then(() &#x3D;&gt;&#123;\n      alert(&quot;恭喜中奖&quot;)\n    &#125;, () &#x3D;&gt; &#123;\n      alert(&#39;谢谢惠顾&#39;)\n    &#125;)\n  &#125;)\n&lt;&#x2F;script&gt;\n&lt;&#x2F;html&gt;\n\npromise的状态是实例对象[PromiseState]的一个属性它有3种状态 \n初始状态&#x2F;未决定的  pending \n当执行结果为成功时状态为pending会变为fullfilled\n当执行结果失败时状态为pending会变为rejected\n一个promise对象只能改变一次无论变为成功还是失败都会返回一个数据结果\n成功数据结果一般称为value\n失败数据结果一般称为reason\nPromise对象的值是实例对象的另一个属性[PromiseResult] 保存成功和失败的结果\n\n相关API\npromise构造函数: new Promise() 接收一个函数作为参数\n参数内部接收两个函数分别为 resolve(成功)  reject(失败) 它们分别执行失败和成功的回调\nPromise.protype.then方法 （’函数一’,’函数二’）&#x3D;&gt; {} \n指定用于得到一个成功或失败的回调返回一个新的promise对象\nPromise.protype.catch 方法 （）&#x3D;&gt; {}\n指定一个失败的回调\nPromise.resolve 方法 (value) &#x3D;&gt; {}\n传入的参数为非promise类型的对象,则返回的结果为成功的promise\n传入的参数为promise对象.则参数的结果决定了resolve的结果\nPromise.reject 方法() &#x3D;&gt; {}\n返回一个失败的promise对象\nPromise.all方法 ([]) &#x3D;&gt; {}\n包含n个promise数组 \n返回一个新的promise,只有所有的promise都成功才成功,只要失败了一个就直接失败\nPromise.race 方法 () &#x3D;&gt; {}\n包含n个promise的数组\n返回一个新的promise 第一个完成的promise的结果状态就是最终的结果状态\n","slug":"Promise的理解和使用","date":"2022-05-15T12:46:25.000Z","categories_index":"技术","tags_index":"ES6,JavaScript","author_index":"小提琴"},{"id":"d5f81ad13155fc328e81b1032965290d","title":"Vuex","content":"Vuex专门在 Vue 中实现集中式状态管理的一个 Vue 插件,对 vue 应用中多个组件的共享状态进行集中式的管理,也是一种组件间通信的方式，且适用于任意组件间通信\n什么时候使用Vuex多个组件依赖同一状态\n来自不同组件的行为需要变更同一状态\nVuex工作原理图\nVuex基本环境&#x2F;&#x2F;引入Vue核心库\nimport Vue from &#39;vue&#39;\n&#x2F;&#x2F;引入Vuex\nimport Vuex from &#39;vuex&#39;\n&#x2F;&#x2F;应用Vuex插件\nVue.use(Vuex)\n   \n&#x2F;&#x2F;准备actions对象——响应组件中用户的动作、处理业务逻辑\nconst actions &#x3D; &#123;&#125;\n&#x2F;&#x2F;准备mutations对象——修改state中的数据\nconst mutations &#x3D; &#123;&#125;\n&#x2F;&#x2F;准备state对象——保存具体的数据\nconst state &#x3D; &#123;&#125;\n   \n&#x2F;&#x2F;创建并暴露store\nexport default new Vuex.Store(&#123;\n   \tactions,\n   \tmutations,\n   \tstate\n&#125;)\n\n初始化数据state, 配置actions, mutations\n组件中读取vuex中的数据: $store.state.”数据名”\n组件中修改vuex中的数据: $store.dispatch(‘actions的方法名’,数据)\n或$store.commit(“mutations中的方法名”,数据)\n若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写dispatch，直接编写commit&#96;\ngetters配置项当state中的数据需要经过加工后再使用时,可以使用getters加工\n在store.js中追加getters配置\nconst getters &#x3D; &#123;\n&#125;\n\n组件读取数据: $store.getters.”数据”\nmap方法的使用mapState: 用于映射state中的数据(一般用于计算属性)\ncomputed: &#123;\n    &#x2F;&#x2F;借助mapState生成计算属性：sum、school、subject（对象写法）\n     ...mapState(&#123;sum:&#39;sum&#39;,school:&#39;school&#39;,subject:&#39;subject&#39;&#125;),\n         \n    &#x2F;&#x2F;借助mapState生成计算属性：sum、school、subject（数组写法）\n    ...mapState([&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),\n&#125;,\n\nmapGetters:用于映射getters中的数据(一般用于计算属性)\ncomputed: &#123;\n    &#x2F;&#x2F;借助mapGetters生成计算属性：bigSum（对象写法）\n    ...mapGetters(&#123;bigSum:&#39;bigSum&#39;&#125;),\n\n    &#x2F;&#x2F;借助mapGetters生成计算属性：bigSum（数组写法）\n    ...mapGetters([&#39;bigSum&#39;])\n&#125;,\n\nmapActions方法:用于生成actions对话的方法(包含$store.dispath()函数)\nmethods:&#123;\n    &#x2F;&#x2F;靠mapActions生成：incrementOdd、incrementWait（对象形式）\n    ...mapActions(&#123;incrementOdd:&#39;jiaOdd&#39;,incrementWait:&#39;jiaWait&#39;&#125;)\n\n    &#x2F;&#x2F;靠mapActions生成：incrementOdd、incrementWait（数组形式）\n    ...mapActions([&#39;jiaOdd&#39;,&#39;jiaWait&#39;])\n&#125;\n\nmapMutations: 用于生成与mutations对话的方法(包含$store.commit()函数)\nmethods:&#123;\n    &#x2F;&#x2F;靠mapMutations生成：increment、decrement（对象形式）\n    ...mapMutations(&#123;increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;&#125;),\n    \n    &#x2F;&#x2F;靠mapMutations生成：JIA、JIAN（对象形式）\n    ...mapMutations([&#39;JIA&#39;,&#39;JIAN&#39;]),\n&#125;\n\nmapActions与mapMutations使用时，若需要传递参数，则需要在模板中绑定事件时传递好参数，否则参数是事件对象\n","slug":"Vuex","date":"2022-05-13T12:46:25.000Z","categories_index":"技术","tags_index":"JavaScript,Vue","author_index":"小提琴"}]