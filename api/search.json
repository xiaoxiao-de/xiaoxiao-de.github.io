[{"id":"5d40e7fe0c283422ee253e93aca4d4aa","title":"VueRouter","content":"VueRouter路由vue 的一个插件库，专门用来实现SPA 应用\n路由一个路由就是一组映射关系\nkey为路径,value就是一个component或者一个方法\n路由分为前端路由和后端路由\n后端路由是一个方法服务器接收到一个请求时，根据请求路径找到匹配的函数来处理请求，返回响应数据\n前端路由:value 是 component，用于展示页面内容，当浏览器的路径改变时，对应的组件就会显示\n路由下载\nnpm i vue-router\n\n\n每个组件都有自己的$route属性，里面存储着自己的路由信息\n\n整个应用只有一个router，可以通过组件的$router属性获取到\n\n子路由跳转：&lt;router-link to=&quot;/a/b&quot;&gt;a&lt;/router-link&gt;\n\n要写（&#x2F;）路径来明确子路由地址\n\n路由to可以省略&#x2F;默认Vue-router给加上了\n\n路由跳转可以携带参数一般存放在query或params\n\n路由的命名可以简化路由的跳转及一些操作\n\n路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置\n\n\n传递参数query\n!-- 跳转并携带query参数，to的字符串写法 --&gt;\n&lt;router-link :to&#x3D;&quot;&#x2F;home&#x2F;message&#x2F;detail?id&#x3D;666&amp;title&#x3D;你好&quot;&gt;跳转&lt;&#x2F;router-link&gt;\n\t\t\t\t\n&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;\n&lt;router-link :to&#x3D;&quot;&#123;\n\tpath:&#39;&#x2F;home&#x2F;message&#x2F;detail&#39;,\n\tquery:&#123;\n\t\tid:666,\n        title:&#39;你好&#39;\n\t&#125;\n&#125;&quot;&gt;跳转&lt;&#x2F;router-link&gt;\n\n\n&#x2F;&#x2F; 接收参数\n$route.query.id\n$route.query.title\n\nparams\n&#x2F;&#x2F; 传递参数\n                &lt;!-- 跳转路由并携带params参数，to的对象写法 --&gt;\n                &lt;router-link :to&#x3D;&quot;&#123;\n                    name:&#39;xiangqing&#39;,\n                    params:&#123;\n                        id:m.id,\n                        title:m.title\n                    &#125;\n                &#125;&quot;&gt;\n                    &#123;&#123;m.title&#125;&#125;\n                &lt;&#x2F;router-link&gt;\n                \n               \n &#x2F;&#x2F; 接收参数\n$route.params.id\n$route.params.title\n\n路由跳转的replace方法控制路由跳转时操作浏览器历史记录的模式\n浏览器的历史记录有两种写入方式：push和replace，其中push是追加历史记录，replace是替换当前记录。路由跳转时候默认为push方式\n开启replace模式：&lt;router-link replace ...&gt;News&lt;/router-link&gt;\nthis.$router.forward() &#x2F;&#x2F;前进\nthis.$router.back() &#x2F;&#x2F;后退\nthis.$router.go() &#x2F;&#x2F;可前进也可后退\n\n缓存路由组件&lt;keep-alive include&#x3D;&quot;&quot;&gt;  &#x2F;&#x2F;include中写想要缓存的组件名，不写表示全部缓存\n\t\t\t\t&lt;router-view&gt;&lt;&#x2F;router-view&gt;\n&lt;&#x2F;keep-alive&gt;\n\n让不展示的路由组件保持挂载，不被销毁\nactivated和deactivated是路由组件所独有的两个钩子，用于捕获路由组件的激活状态\n\nactivated路由组件被激活时触发\ndeactivated&#96;路由组件失活时触发\n\nactivated()&#123;\n           console.log(&#39;News组件被激活了&#39;)\n           this.timer &#x3D; setInterval(() &#x3D;&gt; &#123;\n               this.opacity -&#x3D; 0.01\n               if(this.opacity &lt;&#x3D; 0) this.opacity &#x3D; 1\n           &#125;,16)\n       &#125;,\n       deactivated()&#123;\n           console.log(&#39;News组件失活了&#39;)\n           clearInterval(this.timer)\n       &#125;\n\n全局路由守卫&#x2F;&#x2F;全局前置路由守卫————初始化的时候、每次路由切换之前被调用\nrouter.beforeEach((to,from,next) &#x3D;&gt; &#123;\n    console.log(&#39;前置路由守卫&#39;,to,from)\n    if(to.meta.isAuth)&#123;\n        if(localStorage.getItem(&#39;school&#39;)&#x3D;&#x3D;&#x3D;&#39;atguigu&#39;)&#123;\n            next()\n        &#125;else&#123;\n            alert(&#39;学校名不对，无权限查看！&#39;)\n        &#125;\n    &#125;else&#123;\n        next()\n    &#125;\n&#125;)\n\n&#x2F;&#x2F;全局后置路由守卫————初始化的时候被调用、每次路由切换之后被调用\nrouter.afterEach((to,from)&#x3D;&gt;&#123;\n\tconsole.log(&#39;后置路由守卫&#39;,to,from)\n\tdocument.title &#x3D; to.meta.title || &#39;硅谷系统&#39;\n&#125;)\n&#x2F;&#x2F;独享守卫，特定路由切换之后被调用\n                    beforeEnter(to,from,next)&#123;\n                        console.log(&#39;独享路由守卫&#39;,to,from)\n                        if(localStorage.getItem(&#39;school&#39;) &#x3D;&#x3D;&#x3D; &#39;atguigu&#39;)&#123;\n                            next()\n                        &#125;else&#123;\n                            alert(&#39;暂无权限查看&#39;)\n                        &#125;\n                    &#125;\n &#x2F;&#x2F;通过路由规则，离开该组件时被调用\n        beforeRouteEnter (to, from, next) &#123;\n            console.log(&#39;About--beforeRouteEnter&#39;,to,from)\n            if(localStorage.getItem(&#39;school&#39;)&#x3D;&#x3D;&#x3D;&#39;atguigu&#39;)&#123;\n                next()\n            &#125;else&#123;\n                alert(&#39;学校名不对，无权限查看！&#39;)\n            &#125;\n        &#125;,\n        &#x2F;&#x2F;通过路由规则，离开该组件时被调用\n        beforeRouteLeave (to, from, next) &#123;\n            console.log(&#39;About--beforeRouteLeave&#39;,to,from)\n            next()\n        &#125;\n\n对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值\nhash值不会包含在 HTTP 请求中，即：hash值不会带给服务器\nhash模式：\n地址中永远带着#号，不美观若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法兼容性较好history模式：\n地址干净，美观兼容性和hash模式相比略差应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题\n默认路由地址重定向","slug":"VueRouter路由","date":"2022-05-16T12:46:25.000Z","categories_index":"技术","tags_index":"JavaScript,Vue","author_index":"小提琴"},{"id":"b468f3c3ac71ea2b71e5a5059fe38476","title":"Promise","content":"Promise的理解和使用\npromise是一门新的技术(es6规范)\npromise是异步编程的新解决方案\n从语法上来说:promise是一个构造函数\n从功能上来说:promise对象用来封装异步操作并可以获取成功和失败的结果\npromise: 启动异步任务 &#x3D;&gt; 返回promise对象 &#x3D;&gt; 给promise对象绑定回调函数\n\npromise的优点支持链式调用,可以解决回调地狱问题\n\n\n\n\n\n\n\n\n\n什么是回调地狱？\n回调函数嵌套调用,外部回调函数异步执行的结果是嵌套的回调执行条件\n\n\n\n\n\n\n\n\n\n回调地狱的缺点？\n不便于阅读\n不便于异常处理\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;\n  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n  &lt;title&gt;Document&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  &lt;div class&#x3D;&quot;container&quot;&gt;\n    &lt;button class&#x3D;&quot;btn&quot; id&#x3D;&quot;btn&quot;&gt;点击抽奖&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;script&gt;\n  function rand(m,n) &#123;\n    return Math.ceil(Math.random()*(n-m+1)) + m+1\n  &#125;\n  let btn &#x3D;  document.querySelector(&quot;#btn&quot;)\n  btn.addEventListener(&#39;click&#39;,function()&#123;\n    &#x2F;&#x2F; 原生回调形式\n    &#x2F;&#x2F; setTimeout(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F;   let n &#x3D; rand(1,100)\n    &#x2F;&#x2F;   if(n &lt;&#x3D; 30) &#123;\n    &#x2F;&#x2F;     console.log(n)\n    &#x2F;&#x2F;     alert(&quot;恭喜中奖&quot;)\n    &#x2F;&#x2F;   &#125; else &#123;\n    &#x2F;&#x2F;     console.log(n)\n    &#x2F;&#x2F;     alert(&quot;谢谢惠顾&quot;)\n    &#x2F;&#x2F;   &#125;\n    &#x2F;&#x2F; &#125;,2000)\n    &#x2F;&#x2F; promise形式 promise有两个参数 resolve 返回成功操作\n    &#x2F;&#x2F; reject 表示失败操作  它可以包裹异步操作并对其进行封装\n    let p &#x3D;  new Promise((resolve, reject) &#x3D;&gt; &#123;\n      setTimeout(() &#x3D;&gt; &#123;\n      let n &#x3D; rand(1,100)\n      if(n &lt;&#x3D; 30) &#123;\n        console.log(n)\n        resolve() &#x2F;&#x2F; 将promise对象的状态设置为成功\n      &#125; else &#123;\n        console.log(n)\n        reject() &#x2F;&#x2F; 将promise对象的状态设置为失败\n      &#125;\n    &#125;,1000)\n    &#125;) \n    p.then(() &#x3D;&gt;&#123;\n      alert(&quot;恭喜中奖&quot;)\n    &#125;, () &#x3D;&gt; &#123;\n      alert(&#39;谢谢惠顾&#39;)\n    &#125;)\n  &#125;)\n&lt;&#x2F;script&gt;\n&lt;&#x2F;html&gt;\n\npromise的状态是实例对象[PromiseState]的一个属性它有3种状态 \n初始状态&#x2F;未决定的  pending \n当执行结果为成功时状态为pending会变为fullfilled\n当执行结果失败时状态为pending会变为rejected\n一个promise对象只能改变一次无论变为成功还是失败都会返回一个数据结果\n成功数据结果一般称为value\n失败数据结果一般称为reason\nPromise对象的值是实例对象的另一个属性[PromiseResult] 保存成功和失败的结果\n\n相关API\npromise构造函数: new Promise() 接收一个函数作为参数\n参数内部接收两个函数分别为 resolve(成功)  reject(失败) 它们分别执行失败和成功的回调\nPromise.protype.then方法 （’函数一’,’函数二’）&#x3D;&gt; {} \n指定用于得到一个成功或失败的回调返回一个新的promise对象\nPromise.protype.catch 方法 （）&#x3D;&gt; {}\n指定一个失败的回调\nPromise.resolve 方法 (value) &#x3D;&gt; {}\n传入的参数为非promise类型的对象,则返回的结果为成功的promise\n传入的参数为promise对象.则参数的结果决定了resolve的结果\nPromise.reject 方法() &#x3D;&gt; {}\n返回一个失败的promise对象\nPromise.all方法 ([]) &#x3D;&gt; {}\n包含n个promise数组 \n返回一个新的promise,只有所有的promise都成功才成功,只要失败了一个就直接失败\nPromise.race 方法 () &#x3D;&gt; {}\n包含n个promise的数组\n返回一个新的promise 第一个完成的promise的结果状态就是最终的结果状态\n","slug":"Promise的理解和使用","date":"2022-05-15T12:46:25.000Z","categories_index":"技术","tags_index":"ES6,JavaScript","author_index":"小提琴"}]