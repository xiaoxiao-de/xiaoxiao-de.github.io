[{"id":"cc519f18fc7027e7d44b9a0621d59e8e","title":"小程序","content":"小程序地图功能&#x2F;&#x2F; 小程序内置了一个地图组件map用于展示地图\n &lt;map\n   style&#x3D;&quot;width: 100%; height: 100vh&quot; \n   :latitude&#x3D;&quot;points.latitude&quot; &#x2F;&#x2F; 纬度\n   :longitude&#x3D;&quot;points.longitude&quot;  &#x2F;&#x2F; 经度\n   :markers&#x3D;&quot;covers&quot; &#x2F;&#x2F; 地图中自定义图标点\n   id&#x3D;&quot;map1&quot;\n   ref&#x3D;&quot;map1&quot;\n   show-location\n   @markertap&#x3D;&#39;showMaker&#39;&gt; &#x2F;&#x2F; 图标点击事件\n &lt;&#x2F;map&gt;\n\n&#x2F;&#x2F; js\n&#x2F;&#x2F; 点击地图时获取用户权限,权限获取失败提醒用户是否授权位置\n async findWC() &#123;\n   let that &#x3D; this\n   try&#123;\n     await this.getWxlocation() &#x2F;&#x2F; 调用地图定位方法进行定位\n\t setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F; 进入地图时获取附近建筑点由于使用了async,awitch\n\t   this.getMapData() &#x2F;&#x2F; 这边采用定时器创建一个宏任务使该方法能正常调用\n\t &#125;,1500)\n\t &#125;catch(err)&#123;\n\t  &#x2F;&#x2F; 用户没有授权时提醒用户\n\t   uni.showModal(&#123;\n\t     title: &#96;温馨提示&#96;,\n\t\t content: &#39;获取权限失败,需要获取您的地理位置才能更好的为您服务!,是否授权地理位置?&#39;,\n\t\t showCancel: true,\n\t\t cancelText: &#39;取消&#39;,\n\t\t confirmText: &#39;前往设置&#39;,\n\t\t success(&#123;confirm,cancel&#125;)&#123;\n\t\t   if(confirm)&#123;\n\t\t     that.toSetting() &#x2F;&#x2F; 用户点击前往设置需要授权时调用权限面板\n\t\t     return\n\t\t   &#125;\n\t\t   if(cancel)&#123;\n\t\t     uni.showToast(&#123;\n\t\t\t   title: &#96;取消授权&#96;,\n\t\t\t   icon: &#39;none&#39;\n\t\t\t&#125;)\n\t\t\t&#125;\n\t\t\t&#125;,\n\t\t\t fail()&#123;&#125;\n\t\t\t    &#125;)\n\t\t\t  &#125;\n\t\t\t&#125;\n\t\t\t点击时获得自己的位置并发送请求给后端查询附近的建筑点\n&#x2F;&#x2F; 调用用户手机授权面板获取位置权限\n  toSetting()&#123;\n    let that &#x3D; this\n\tuni.openSetting(&#123;\n\t  success(res)&#123;\n\t  &#x2F;&#x2F; 判断用户是否选中地图权限\n\t    if(res.authSetting[&#39;scope.userLocation&#39;])&#123;\n\t      uni.showToast(&#123;\n\t\t  title: &#39;授权成功&#39;,\n\t\t  icon: &#39;none&#39;\n\t\t&#125;)\n\t    &#125;\n\t\t&#125;  \n\t\t&#125;)\n\t &#125;\n&#x2F;&#x2F; 地图定位\ngetWxlocation()&#123;\n  let that &#x3D; this\n  uni.showLoading(&#123;\n    title: &#39;定位中...&#39;,\n\tmask: true\n  &#125;)\n  &#x2F;&#x2F; 采用promise对获取位置进行封装\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    const locationChange &#x3D; (res) &#x3D;&gt; &#123;\n\t  that.points.latitude &#x3D; res.latitude &#x2F;&#x2F; 获取返回来的经纬度\n      that.points.longitude &#x3D; res.longitude\n\t  uni.hideLoading() &#x2F;&#x2F; 隐藏加载动画\n\t  wx.offLocationChange(locationChange) &#x2F;&#x2F; 解除绑定\n\t  that.flag &#x3D; true \n\t  &#125;\n\t  &#x2F;&#x2F; 获取位置\n\t\twx.startLocationUpdate(&#123;\n\t\t  success(res)&#123;\n\t\t    wx.onLocationChange(locationChange)\n\t\t\tresolve()\n\t\t &#125;,\n\t\t  fail(err)&#123;\n\t\t    uni.showToast(&#123;\n\t\t\t  title: &#96;获取位置失败$&#123;err&#125;&#96;,\n\t\t\t  icon: &#39;none&#39;\n\t\t\t&#125;)\n\t\t\tuni.hideLoading()\n\t\t\treject()\n\t\t\t&#125;\n\t\t   &#125;)\n\t\t   &#125;)\n\t\t&#125;\n\n","slug":"小程序地图功能","date":"2022-08-07T12:48:01.000Z","categories_index":"技术","tags_index":"小程序","author_index":"小提琴"},{"id":"cc519f18fc7027e7d44b9a0621d59e8e","title":"小程序","content":"uni上传功能&#x2F;&#x2F;上传图片\n\t\t\tchooseImage() &#123;\n\t\t\t\tlet that &#x3D; this;\n\t\t\t\tlet imgArr &#x3D; that.imgArr;\n\t\t\t\tlet imgTemp &#x3D; &#39;&#39;\n\t\t\t\t&#x2F;&#x2F;选择图片文件\n\t\t\t\tuni.chooseImage(&#123;\n\t\t\t\t\tcount:5, &#x2F;&#x2F;最多可以选择的图片数量\n\t\t\t\t\tsourceType: [&#39;album&#39;], &#x2F;&#x2F;图片来源是相册   相机:&#39;camera&#39;\n\t\t\t\t\tsuccess(res) &#123;\n\t\t\t\t\t\tuni.showToast(&#123;\n\t\t\t\t\t\t        title: &#39;正在上传...&#39;,\n\t\t\t\t\t\t        icon: &#39;loading&#39;,\n\t\t\t\t\t\t        mask: true,\n\t\t\t\t\t\t        duration: 2000\n\t\t\t\t\t\t      &#125;)\n\t\t\t\t\t\tif(imgArr.length &lt; 5)&#123;\n\t\t\t\t\t\t\timgArr.push(...res.tempFilePaths); &#x2F;&#x2F;不满5张追加到数组\n\t\t\t\t\t\t\t&#x2F;&#x2F; console.log(222,imgArr)\n\t\t\t\t\t\t\timgTemp &#x3D; res.tempFilePaths[0]\n\t\t\t\t\t\t&#125;else&#123;\n\t\t\t\t\t\t\treturn uni.showToast(&#123;\n\t\t\t\t\t\t\t\ttitle: &#39;最多可以选择5张图片&#39;,\n\t\t\t\t\t\t\t\ticon: &#39;none&#39;\n\t\t\t\t\t\t\t&#125;)\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t&#x2F;&#x2F; 上传图片uni.uploadFile\n\t\t\t\t\t\t  uni.uploadFile(&#123;\n\t\t\t\t\t\t  \turl: api.baseApi + &#39;sys&#x2F;common&#x2F;upload&#39;,\n\t\t\t\t\t\t  \tfilePath: imgTemp,\n\t\t\t\t\t\t\tname: &#39;file&#39;,\n\t\t\t\t\t\t  \tfileType: &#39;image&#39;,\n\t\t\t\t\t\t  \tformData: &#123;\n\t\t\t\t\t\t      biz: &#39;temp&#39;\n\t\t\t\t\t\t  \t&#125;,\n\t\t\t\t\t\t  \theader: &#123;\n\t\t\t\t\t\t  \t        &#39;X-Access-Token&#39;: that.$store.state.token\n\t\t\t\t\t\t  \t      &#125;,\n\t\t\t\t\t\t  \tsuccess(res) &#123;\n\t\t\t\t\t\t  \t\tconsole.log(&#39;上传成功&#39;)\n\t\t\t\t\t\t  \t\tlet &#123; data &#125; &#x3D; res &#x2F;&#x2F;res.data是字符串类型，需要转换为对象\n\t\t\t\t\t\t\t\tlet &#123; message &#125; &#x3D; JSON.parse(data)\n\t\t\t\t\t\t\t\tthat.imgList.push(message)\t\t\t\t\t\t\t\n\t\t\t\t\t\t  \t&#125;,\n\t\t\t\t\t\t  \tfail(error) &#123;\n\t\t\t\t\t\t  \t\tuni.showToast(&#123;\n\t\t\t\t\t\t  \t\t  title: &#96;上传失败&#96;,\n\t\t\t\t\t\t\t\t  icon: &#39;none&#39;\n\t\t\t\t\t\t  \t\t&#125;)\n\t\t\t\t\t\t  \t&#125;\n\t\t\t\t\t\t  &#125;)\n\t\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;)\n\t\t\t&#125;,\n\t\t\t&#x2F;&#x2F; 点击预览图片\n\t\t\timgbox(item) &#123;\n\t\t\t\tuni.previewImage(&#123;\n\t\t\t\t\tcurrent:item,\n\t\t\t\t\turls: this.imgArr\n\t\t\t\t&#125;)\n\t\t\t&#125;,\n\t\t\t&#x2F;&#x2F; 删除图片\n\t\t\tdeleteImg(index) &#123;\n\t\t\t\tvar that &#x3D; this;\n\t\t\t\tuni.showModal(&#123;\n\t\t\t\t\ttitle: &#39;删除&#39;,\n\t\t\t\t\tcontent: &#39;确认删除当前图片&#39;,\n\t\t\t\t\tsuccess(res) &#123;\n\t\t\t\t\t\t&#x2F;&#x2F; 用户点击确认时\n\t\t\t\t\t\tif(res.confirm) &#123;\n\t\t\t\t\t\t\tthat.imgList &#x3D; that.imgList.filter((item,key) &#x3D;&gt; key !&#x3D;&#x3D; index)\n\t\t\t\t\t\t\tthat.imgArr.splice(index,1);\n\t\t\t\t\t\t\t&#x2F;&#x2F; console.log(that.imgList)\n\t\t\t\t\t\t&#125;else if(res.cancel) &#123; \n\t\t\t\t\t\t&#x2F;&#x2F; 用户点击取消时\n\t\t\t\t\t\t\tuni.showToast(&#123;\n\t\t\t\t\t\t\t  title: &#39;已取消&#39;,\n\t\t\t\t\t\t\t  icon: &#39;none&#39;\n\t\t\t\t\t\t\t&#125;)\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;)\n\t\t\t&#125;,\n\n","slug":"uni上传功能","date":"2022-08-07T12:48:01.000Z","categories_index":"技术","tags_index":"小程序","author_index":"小提琴"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"git日常使用\ngit是一个开源的分布式版本控制系统\ngit有3个工作区 workspace工作区 staging area 暂存区\nlocal repository 本地仓库 remote repository 远程仓库git基本操作git clone &lt;仓库地址&gt;\n拷贝一个git仓库到本地\n\ngit branch\n用于查看本地仓库分支和远程仓库分支\n\ngit remote add [shortname] [url]\n添加远程版本库\n\ngit fetch\n用于从远程获取代码库\n\ngit checkout &lt;本地分支名&gt;\n切换本地分支\n\ngit pull &lt;本地分支名&gt;\n用于从远程获取代码并合并本地的版本\n\ngit add .\n添加当前目录下的所有文件到暂存区\n\ngit commit -m [message]\n将暂存区内容添加到本地仓库\n\ngit push &lt;本地分支名&gt;丨&lt;远程分支名&gt;\n用于从将本地的分支版本上传到远程并合并\n\n\n需求开发前的分支拉取流程\n需求开发后的分支合并流程\n分支合并出现的冲突如何解决\n出现线上问题时hotfix分支的操作流程\n\n","slug":"git日常使用","date":"2022-06-29T14:04:47.959Z","categories_index":"","tags_index":"","author_index":"小提琴"},{"id":"af1ec4b22e6834df21b119ba73ac155f","title":"ui库input文本框","content":"自定义封装input文本框前置知识\nvue过渡动画\nsync修饰符\n具名插槽与v-slot指令\n\n参数\n\n\n\n参数名\n参数描述\n参数类型\n默认值\n\n\n\ntitle\n对话框标题\nstring\n提示\n\n\nwidth\n宽度\nstring\n50%\n\n\ntop\n与顶部距离\nstring\n200px\n\n\nvisible\n是否显示dialog（支持sync修饰符)\nboolean\nfalse\n\n\n事件\n\n\n\n事件名\n事件描述\n\n\n\nopened\n模态框显示事件\n\n\nclosed\n模态框关闭事件\n\n\n插槽\n\n\n\n插槽名称\n插槽描述\n\n\n\ndefault\ndialog的内容\n\n\ntitle\ndialog标题\n\n\nfooter\ndialog底部操作区\n\n\n&lt;template&gt;\n&lt;!-- 使用transition标签包裹之后就会自动添加动画类 --&gt;\n&lt;!-- name指定动画名称 --&gt;\n&lt;transition name&#x3D;&quot;dialog&quot;&gt;\n  &lt;!-- 通过v-show来进行显示隐藏 --&gt;\n  &lt;!-- self代表点击自己才触发事件 --&gt;\n &lt;div class&#x3D;&quot;qi-dialog_wrapper&quot; v-show&#x3D;&quot;visible&quot; @click.self&#x3D;&quot;handleClose&quot;&gt;\n   &lt;div class&#x3D;&quot;qi-dialog&quot; :style&#x3D;&quot;&#123; width: width, &#39;margin-top&#39;: top&#125;&quot;&gt;\n     &lt;div class&#x3D;&quot;qi-dialog_header&quot;&gt;\n       &lt;!-- 使用具名插槽方式 --&gt;\n       &lt;slot name&#x3D;&#39;title&#39;&gt;\n         &lt;span class&#x3D;&quot;qi-dialog_title&quot;&gt;\n         &#123;&#123; title &#125;&#125;\n       &lt;&#x2F;span&gt;\n       &lt;&#x2F;slot&gt;\n       &lt;button class&#x3D;&quot;qi-dialog_headerbtn&quot;&gt;\n         &lt;i class&#x3D;&quot;qi-icon-close&quot; @click.self&#x3D;&quot;handleClose&quot;&gt;&lt;&#x2F;i&gt;\n       &lt;&#x2F;button&gt;\n     &lt;&#x2F;div&gt;\n     &lt;div class&#x3D;&quot;qi-dialog_body&quot;&gt;\n       &lt;!-- 自定义body内容 --&gt;\n       &lt;slot&gt;&lt;&#x2F;slot&gt;\n     &lt;&#x2F;div&gt;\n     &lt;div class&#x3D;&quot;qi-dialog_footer&quot; v-if&#x3D;&quot;$slots.footer&quot;&gt;\n       &lt;slot name&#x3D;&quot;footer&quot;&gt;\n\n       &lt;&#x2F;slot&gt;\n     &lt;&#x2F;div&gt;\n   &lt;&#x2F;div&gt;\n &lt;&#x2F;div&gt;\n&lt;&#x2F;transition&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nexport default &#123;\n  name: &#39;QiDialog&#39;,\n  props: &#123;\n    &#x2F;&#x2F; 标题\n    title: &#123;\n      type: String,\n      default: &#39;提示&#39;\n    &#125;,\n    &#x2F;&#x2F; 宽度\n    width: &#123;\n      type: String,\n      default: &#39;50%&#39;\n    &#125;,\n    &#x2F;&#x2F; 高度\n    top: &#123;\n      type: String,\n      default: &#39;200px&#39;\n    &#125;,\n    &#x2F;&#x2F; 显示隐藏\n    visible: &#123;\n      type: Boolean,\n      default: false\n    &#125;\n  &#125;,\n  methods: &#123;\n    handleClose () &#123;\n      &#x2F;&#x2F; 通过update:visible方式可以使用sync修饰符来简化子传父\n      &#x2F;&#x2F; 回调给父元素进行更改\n      &#x2F;&#x2F; 作用于事件名和属性相同时\n      this.$emit(&#39;update:visible&#39;, false)\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n&lt;style lang&#x3D;&#39;scss&#39; scoped&gt;\n.qi-dialog_wrapper&#123;\n  position: fixed;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  overflow: auto;\n  margin: 0;\n  z-index: 2001;\n  background-color: rgba(0,0,0,0.5);\n  .qi-dialog&#123;\n    position: relative;\n    margin: 15vh auto 50px;\n    background: #fff;\n    border-radius: 2px;\n    box-shadow: 0 1px 3px rgba(0,0,0,0.3);\n    box-sizing: border-box;\n    width: 30%;\n    &amp;_header&#123;\n      padding: 20px 20px 10px;\n      .qi-dialog_title&#123;\n        line-height: 24px;\n        font-size: 18px;\n        color: #303133;\n      &#125;\n      .qi-dialog_headerbtn&#123;\n        position: absolute;\n        top: 20px;\n        right: 20px;\n        padding: 0;\n        background: transparent;\n        border: none;\n        outline: none;\n        cursor: pointer;\n        font-size: 16px;\n        .qi-icon-close&#123;\n          color:909399\n        &#125;\n      &#125;\n    &#125;\n    &amp;_body&#123;\n      padding: 30px 20px;\n      color: #606266;\n      font-size: 14px;\n      word-break: break-all;\n    &#125;\n    &amp;_footer&#123;\n      padding: 10px 20px 20px;\n      text-align: right;\n      box-sizing: border-box;\n      ::v-deep .qi-button:first-child&#123;\n        margin-right: 20px;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n&#x2F;&#x2F; 进入页面\n.dialog-enter-active &#123;\n  animation: run .9s;\n&#125;\n&#x2F;&#x2F; 离开页面\n.dialog-leave-actuve &#123;\n  animation: run .9s reverse;\n&#125;\n&#x2F;&#x2F; 动画\n@keyframes run &#123;\n  0% &#123;\n    opacity: 0;\n    transform: translateY(-30px);\n  &#125;\n  100% &#123;\n    opacity: 1;\n    transform: translateY(0px);\n  &#125;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n","slug":"自定义封装dialog对话框","date":"2022-06-27T03:48:12.000Z","categories_index":"ui库","tags_index":"ui库","author_index":"小提琴"},{"id":"af1ec4b22e6834df21b119ba73ac155f","title":"ui库input文本框","content":"自定义封装input文本框参数\n\n\n\n参数名称\n参数描述\n参数类型\n默认值\n\n\n\nplaceholder\n占位符\nstring\n无\n\n\ntype\n文本框类型(text&#x2F;password)\nstring\ntext\n\n\ndisabled\n禁用\nboolean\nfalse\n\n\nclearable\n是否显示清空按钮\nboolean\nfalse\n\n\nshow-password\n是否显示密码切换\nboolean\nfalse\n\n\nname\nname属性\nstring\n无\n\n\n事件\n\n\n\n事件名称\n事件描述\n\n\n\nblur\n失去焦点事件\n\n\nchange\n内容改变事件\n\n\nfocus\n获取焦点事件\n\n\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;qi-input&quot;\n  :class&#x3D;&quot;&#123;&#39;qi-input_suffix&#39;: showSuffix&#125;&quot;&gt;\n  &lt;!-- 判断showPassword是否为真 --&gt;\n  &lt;!-- 为真通过passWordVisible去判断type类型来控制隐藏 --&gt;\n    &lt;input\n    :type&#x3D;&quot;showPassword ? (passWordVisible ? &#39;text&#39; : &#39;password&#39;) : type&quot;\n    class&#x3D;&quot;qi-input_inner&quot;\n    :class&#x3D;&quot;[&#123;&#39;is-disabled&#39;: disabled&#125;]&quot;\n    :placeholder&#x3D;&#39;placeholder&#39;\n    :name&#x3D;&quot;name&quot;\n    :disabled&#x3D;&quot;disabled&quot;\n    :value&#x3D;&quot;value&quot;\n    @input&#x3D;&quot;handlerInput&quot;\n     &#x2F;&gt;\n      &lt;span class&#x3D;&quot;qi-input_suffix&quot; v-if&#x3D;&quot;showSuffix&quot;&gt;\n        &lt;!--触发input回调当点击时清空targrt值当没值是不显示文本  --&gt;\n   &lt;i class&#x3D;&quot;qi-input_icon qi-icon-cancel&quot; \n   v-if&#x3D;&quot;clearable &amp;&amp; value&quot;\n   @click&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;i&gt;\n   &lt;i class&#x3D;&quot;qi-input_icon qi-icon-visible&quot;\n   v-if&#x3D;&quot;showPassword&quot;\n   :class&#x3D;&quot;&#123;&#39;qi-icon-view-active&#39;: passWordVisible&#125;&quot;\n   @click&#x3D;&quot;handleShow&quot;&gt;&lt;&#x2F;i&gt;\n &lt;&#x2F;span&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;QiInput&#39;,\n  data () &#123;\n    return &#123;\n      passWordVisible: false\n    &#125;\n  &#125;,\n  props: &#123;\n    &#x2F;&#x2F; 输入框提示\n    placeholder: &#123;\n      type: String,\n      default: &#39;&#39;\n    &#125;,\n    &#x2F;&#x2F; 输入框类型\n    type: &#123;\n      type: String,\n      default: &#39;text&#39;\n    &#125;,\n    &#x2F;&#x2F; 输入框name\n    name: &#123;\n      type: String,\n      default: &#39;&#39;\n    &#125;,\n    &#x2F;&#x2F; 是否禁用\n    disabled: &#123;\n      type: Boolean,\n      default: false\n    &#125;,\n    &#x2F;&#x2F; 输入框值\n    value: &#123;\n      type: String,\n      default: &#39;&#39;\n    &#125;,\n    &#x2F;&#x2F; 清空\n    clearable: &#123;\n      type: Boolean,\n      default: false\n    &#125;,\n    &#x2F;&#x2F; 显示密码\n    showPassword: &#123;\n      type: Boolean,\n      default: false\n    &#125;\n  &#125;,\n  computed: &#123;\n    showSuffix () &#123;\n      return this.clearable || this.showPassword\n    &#125;\n  &#125;,\n  methods: &#123;\n    handlerInput (&#123; target &#125;) &#123;\n         &#x2F;*\n     当给一个innput标签进行双向绑定要给父元素传值时\n     需要获得value值 在使用input事件监听标签内数据\n     在组件内使用v-model显然时不合适的\n     我们可以通过v-mode特性进行操作\n     由于v-model绑定的是value值\n     且自动绑定了input事件\n     可以通过发射input事件传输入当前target值进行双向绑定\n    *&#x2F;\n      this.$emit(&#39;input&#39;, target.value)\n    &#125;,\n    clear () &#123;\n      this.$emit(&#39;input&#39;, &#39;&#39;)\n    &#125;,\n    handleShow () &#123;\n      this.passWordVisible &#x3D; !this.passWordVisible\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n&lt;style lang&#x3D;&#39;scss&#39; scoped&gt;\n.qi-input&#123;\n    width: 100%;\n    position: relative;\n    font-size: 14px;\n    display: inline-block;\n    .qi-input_inner&#123;\n      -webkit-appearance: none;\n      background-color: #fff;\n      background-image: none;\n      border: 1px solid #dcdfe6;\n      border-radius: 4px;\n      box-sizing: border-box;\n      color: #606266;\n      display: inline-block;\n      font-size: inherit;\n      height: 40px;\n      line-height: 40px;\n      outline: none;\n      padding: 0 15px;\n      transition: border-color .2s cubic-bezier(.645,045,.355,1);\n      width: 100%;\n      &amp;:focus&#123;\n        outline: none;\n        border-color: #409eff;\n      &#125;\n      &#x2F;&#x2F; input禁用样式\n      &amp;.is-disabled&#123;\n        background-color: #f5f7fa;\n        border-color: #e4e7ed;\n        color: #c0c4cc;\n        cursor:not-allowed;\n      &#125;\n    &#125;\n  &#125;\n  .qi-input_suffix&#123;\n    .qi-input_inner&#123;\n      padding-right: 30px;\n    &#125;\n    .qi-input_suffix&#123;\n      position: absolute;\n      right: 10px;\n      height: 100%;\n      top: 0;\n      line-height: 40px;\n      text-align: center;\n      color: #c0c4cc;\n      transition: all .3s;\n      z-index: 900;\n      i&#123;\n        color: #c0c4cc;\n        font-size: 14px;\n        cursor: pointer;\n        transition: color .2s cubic-bezier(.645,.045,.355,1);\n      &#125;\n      .qi-icon-view-active &#123;\n        color: #409eff;\n      &#125;\n    &#125;\n  &#125;\n&lt;&#x2F;style&gt;\n\n\n","slug":"自定义封装input文本框","date":"2022-06-27T03:48:12.000Z","categories_index":"ui库","tags_index":"ui库","author_index":"小提琴"},{"id":"315d13c18c53836143d04f0454f73ada","title":"ui库radio与radio-group组件","content":"自定义封装radio与radio-group组件参数\n\n\n\n参数名称\n参数描述\n参数类型\n默认值\n\n\n\nv-model\n双向绑定\nboolean\nfasle\n\n\nlabel\n单选框和value\nstring，number，Boolean\n无\n\n\nname\nname\nstring\n无\n\n\n&lt;template&gt;\n&lt;!-- 点击是样式为选中状态 --&gt;\n&lt;!-- label等于model时为选中状态 --&gt;\n  &lt;label class&#x3D;&quot;qi-radio&quot;\n  :class&#x3D;&quot;&#123;&#39;is-checked&#39;: label &#x3D;&#x3D;&#x3D; model&#125;&quot;&gt;\n    &lt;span class&#x3D;&quot;qi-radio_input&quot;&gt;\n      &lt;span class&#x3D;&quot;qi-radio_inner&quot;&gt;&lt;&#x2F;span&gt;\n      &lt;input\n      type&#x3D;&quot;radio&quot;\n      class&#x3D;&quot;qi-radio_original&quot;\n      :value&#x3D;&quot;label&quot;\n      :name&#x3D;&quot;name&quot;\n      v-model&#x3D;&quot;model&quot;\n      &gt;\n    &lt;&#x2F;span&gt;\n    &lt;span class&#x3D;&quot;qi-radio_label&quot;&gt;\n      &lt;slot&gt;&lt;&#x2F;slot&gt;\n      &lt;template v-if&#x3D;&quot;!$slots.default&quot;&gt;\n        &#123;&#123; label &#125;&#125;\n      &lt;&#x2F;template&gt;\n    &lt;&#x2F;span&gt;\n  &lt;&#x2F;label&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;QiRadio&#39;,\n  &#x2F;&#x2F; 通过group传来的参数在计算属性中进行计算\n  inject: &#123;\n    RadioGroup: &#123;\n      default: &#39;&#39;\n    &#125;\n  &#125;,\n  props: &#123;\n    label: &#123;\n      type: [String, Number, Boolean],\n      default: &#39;&#39;\n    &#125;,\n    value: null,\n    name: &#123;\n      type: String,\n      default: &#39;&#39;\n    &#125;\n  &#125;,\n  computed: &#123;\n    model: &#123;\n      &#x2F;*\n      实现radio组件的双向绑定外还需要控制radio的样式\n      实现radio组件数据绑定需要父组件的label和value\n      value通过父组件的v-model获得\n      当value点击时应将value的值绑定为label属性\n      通过计算属性方式将值绑定在input标签中\n      当值发生变动时传给父组件\n      在得到父组件传来的值\n       *&#x2F;\n      &#x2F;&#x2F; 判断是否是RadioGroup组件的value\n      get () &#123;\n        return this.isGroup ? this.RadioGroup.value : this.value\n      &#125;,\n      set (value) &#123;\n        this.isGroup ? this.RadioGroup.$emit(&#39;input&#39;, value) : this.$emit(&#39;input&#39;, value)\n      &#125;\n    &#125;,\n    isGroup () &#123;\n      return !!this.RadioGroup\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n  .qi-radio&#123;\n    color: #606266;\n    font-weight: 500;\n    line-height: 1;\n    position: relative;\n    cursor: pointer;\n    display: inline-block;\n    white-space: nowrap;\n    outline: none;\n    font-size: 14px;\n    margin-right: 30px;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    .qi-radio_input&#123;\n      white-space: nowrap;\n      cursor: pointer;\n      outline: none;\n      display: inline-block;\n      line-height: 1;\n      position: relative;\n      vertical-align: middle;\n      .qi-radio_inner&#123;\n        border: 1px solid #dcdfe6;\n        border-radius: 100%;\n        width: 14px;\n        height: 14px;\n        background-color: #fff;\n        position: relative;\n        cursor: pointer;\n        display: inline-block;\n        box-sizing: border-box;\n        &amp;:after&#123;\n          width: 4px;\n          height: 4px;\n          border-radius: 100%;\n          background-color: #fff;\n          content: &quot;&quot;;\n          position: absolute;\n          left: 50%;\n          top: 50%;\n          transform: translate(-50%,-50%) scale(0);\n          transition: transform .15s ease-in;\n        &#125;\n      &#125;\n      .qi-radio_original&#123;\n        opacity: 0;\n        outline: none;\n        position: absolute;\n        z-index: -1;\n        top: 0;\n        left: 0px;\n        right: 0;\n        bottom: 0;\n        margin: 0;\n      &#125;\n    &#125;\n    .qi-radio_label&#123;\n      font-size: 14px;\n      padding-left: 10px;;\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 选中的样式\n  .qi-radio.is-checked&#123;\n    .qi-radio_input&#123;\n      .qi-radio_inner&#123;\n        border-color: #409eff;\n        background-color: #409eff;\n        &amp;:after&#123;\n          transform: translate(-50%,-50%) scale(1);\n        &#125;\n      &#125;\n    &#125;\n    .qi-radio_label&#123;\n      color:#409eff;\n    &#125;\n  &#125;\n&lt;&#x2F;style&gt;\n\n\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;qi-radio-group&quot;&gt;\n    &lt;slot&gt;&lt;&#x2F;slot&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;QiRadioGroup&#39;,\n  &#x2F;*\n  radio-group组件目的是在使用radio时不用给每个组件添加v-model\n  通过给它绑定一个v-model实现功能\n  组件件通信需要使用provide和inject进行祖孙通信\n  *&#x2F;\n  provide () &#123;\n    return &#123;\n      RadioGroup: this\n    &#125;\n  &#125;,\n  props: &#123;\n    value: null\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n\n","slug":"自定义封装radio组件","date":"2022-06-27T03:48:12.000Z","categories_index":"ui库","tags_index":"ui库","author_index":"小提琴"},{"id":"0e15c5d790782cba4ebaaf850d67592f","title":"ui库switch开关","content":"自定义封装switch开关\n\n\n参数名\n参数描述\n参数类型\n默认值\n\n\n\nv-model\n双向绑定\nBoolean\nfalse\n\n\nname\nname属性\nString\ntext\n\n\nactiveColor\n自定义的激活颜色\nString\n#1ec63b\n\n\ninactiveColor\n自定义不激活颜色\nString\n#dd001b\n\n\n事件\n\n\n\n事件名称\n事件描述\n\n\n\nchange\nchange时触发的事件\n\n\n&lt;template&gt;\n&lt;!-- 点击时触发滑块滑动改变样式 --&gt;\n   &lt;div class&#x3D;&quot;qi-switch&quot; \n   :class&#x3D;&quot;&#123;&#39;is-checked&#39;: value&#125;&quot; \n   @click&#x3D;&quot;handleClick&quot;&gt;\n   &#x2F;&#x2F;&#x2F;因为switch是表单组件 有可能会用到name这边使用复选框\n     &lt;input class&#x3D;&quot;qi-switch_input&quot;\n     type&#x3D;&quot;checkbox&quot;\n     :name&#x3D;&#39;name&#39;\n     ref&#x3D;&#39;input&#39;&#x2F;&gt;\n    &lt;span class&#x3D;&quot;qi-switch_core&quot; ref&#x3D;&quot;core&quot;&gt;\n      &lt;span class&#x3D;&quot;qi-switch_button&quot;&gt;&lt;&#x2F;span&gt;\n    &lt;&#x2F;span&gt;\n   &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;QiSwitch&#39;,\n  props: &#123;\n    &#x2F;&#x2F; value值\n    value: &#123;\n      type: Boolean,\n      default: false\n    &#125;,\n    &#x2F;&#x2F; 自定义颜色按下\n    activeColor: &#123;\n      type: String,\n      default: &#39;&#39;\n    &#125;,\n    &#x2F;&#x2F; 自定义颜色松开\n    inactiveColor: &#123;\n      type: String,\n      default: &#39;&#39;\n    &#125;,\n    &#x2F;&#x2F; name属性\n    name: &#123;\n      type: String,\n      default: &#39;&#39;\n    &#125;\n  &#125;,\n  &#x2F;&#x2F; watch: &#123;\n  &#x2F;&#x2F;   &#39;value&#39; (newValue) &#123;\n  &#x2F;&#x2F;     &#x2F;&#x2F; 修改开关颜色\n  &#x2F;&#x2F;     if (this.activeColor || this.inactiveColor) &#123;\n  &#x2F;&#x2F;       const color &#x3D; this.value ? this.activeColor : this.inactiveColor\n  &#x2F;&#x2F;       this.$refs.core.style.borderColor &#x3D; color\n  &#x2F;&#x2F;       this.$refs.core.style.backgroundColor &#x3D; color\n  &#x2F;&#x2F;     &#125;\n  &#x2F;&#x2F;   &#125;\n  &#x2F;&#x2F; &#125;,\n  mounted () &#123;\n    this.setColor()\n    this.$refs.input.checked &#x3D; this.value\n  &#125;,\n  methods: &#123;\n    async handleClick () &#123;\n      &#x2F;&#x2F; 通过父组件绑定v-model获取value属性和input\n      &#x2F;&#x2F; 发射事件传给父元素改变值\n      this.$emit(&#39;input&#39;, !this.value)\n      await this.$nextTick()\n      this.$refs.input.checked &#x3D; this.value\n      this.setColor()\n    &#125;,\n    setColor () &#123;\n      if (this.activeColor || this.inactiveColor) &#123;\n        const color &#x3D; this.value ? this.activeColor : this.inactiveColor\n        this.$refs.core.style.borderColor &#x3D; color\n        this.$refs.core.style.backgroundColor &#x3D; color\n      &#125;\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&#39;scss&#39; scoped&gt;\n.qi-switch&#123;\n    display: inline-block;\n    align-items: center;\n    position: relative;\n    font-size: 14px;\n    line-height: 20px;\n    vertical-align: middle;\n  .qi-switch_core&#123;\n    margin: 0;\n    display: inline-block;\n    position: relative;\n    width: 40px;\n    height: 20px;\n    border: 1px solid #dcdfe6;\n    outline: none;\n    border-radius: 10px;\n    box-sizing: border-box;\n    background: #dcdfe6;\n    cursor: pointer;\n    transition: border-color .3s,background-color .3s;\n    vertical-align: middle;\n    .qi-switch_button&#123;\n      position:absolute;\n      top: 1px;\n      left: 1px;\n      border-radius: 100%;\n      transition: all .3s;\n      width: 16px;\n      height: 16px;\n      background-color: #fff;\n      &#125;\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 滑动样式\n  .is-checked &#123;\n    .qi-switch_core&#123;\n      border-color: #409eff;\n      background-color: #409eff;\n      .qi-switch_button &#123;\n        transform: translateX(20px);\n      &#125;\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 隐藏input\n  .qi-switch_input&#123;\n    position:absolute;\n    width: 0;\n    height: 0;\n    opacity: 0;\n    margin: 0;\n  &#125;\n&lt;&#x2F;style&gt;\n\n\n","slug":"自定义封装switch开关","date":"2022-06-27T03:48:12.000Z","categories_index":"ui库","tags_index":"ui库","author_index":"小提琴"},{"id":"32a3ee3e88f21c8f7c84d017e1289b77","title":"ui库ui-button按钮","content":"自定义封装ui-button按钮知识点\n\n组件通信\n组件插槽\nprops校验\n\n参数\n\n\n\n参数名\n参数描述\n参数类型\n默认值\n\n\n\ntype\n按钮类型(info,success,primary,waring,danger)\nstrign\ndefault\n\n\nplain\n是否朴素按钮\nboolean\nfalse\n\n\nround\n是否圆角按钮\nboolean\nfalse\n\n\ncircle\n是否圆形按钮\nboolean\nfalse\n\n\ndisabled\n是否禁用按钮\nboolean\nfalse\n\n\nicon\n图标类型\nstrign\nnull\n\n\n事件\n\n\n\n事件名\n事件描述\n\n\n\nclick\n点击事件\n\n\n&lt;template&gt;\n  &lt;button class&#x3D;&quot;qi-button&quot;\n  &#x2F;&#x2F; 判断是哪个按钮\n  :class&#x3D;&quot;[&#96;qi-button-$&#123;type&#125;&#96;,\n  &#x2F;&#x2F; 是否开启朴素按钮\n   &#123;&#39;is-plain&#39;: plain&#125;,\n   &#x2F;&#x2F; 是否是圆角\n   &#123;&#39;is-round&#39;: round&#125;,\n   &#x2F;&#x2F; 是否是圆形按钮\n   &#123;&#39;is-circle&#39;: circle&#125;,\n   &#x2F;&#x2F; 是否禁用\n   &#123;&#39;is-disabled&#39;: disabled&#125;]&quot;\n   @click&#x3D;&quot;handlerClick&quot;\n   :disabled&#x3D;&#39;disabled&#39;&gt;\n   &lt;i v-if&#x3D;&quot;icon&quot; :class&#x3D;&quot;[&#96;qi-icon-$&#123;icon&#125;&#96;]&quot;&gt;&lt;&#x2F;i&gt;\n   &lt;!-- 通过$slots.default进行判断默认插槽是否是文字按钮是否有图标 --&gt;\n    &lt;span v-if&#x3D;&quot;$slots.default&quot;&gt;\n      &lt;slot&gt;&lt;&#x2F;slot&gt;\n    &lt;&#x2F;span&gt;\n    &lt;&#x2F;button&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nexport default &#123;\n  name: &#39;QiButton&#39;,\n  props: &#123;\n    &#x2F;&#x2F; 按钮类型 如果不传值默认为default\n    type: &#123;\n      type: String,\n      default: &#39;default&#39;\n    &#125;,\n    &#x2F;&#x2F; 是否是朴素按钮\n    plain: &#123;\n      type: Boolean,\n      default: false\n    &#125;,\n    &#x2F;&#x2F; 圆角按钮\n    round: &#123;\n      type: Boolean,\n      default: false\n    &#125;,\n    &#x2F;&#x2F; 圆形按钮\n    circle: &#123;\n      type: Boolean,\n      default: false\n    &#125;,\n    &#x2F;&#x2F; 图标\n    icon: &#123;\n      type: String,\n      default: &#39;&#39;\n    &#125;,\n    &#x2F;&#x2F; 是否禁用\n    disabled: &#123;\n      type: Boolean,\n      default: false\n    &#125;\n  &#125;,\n  created () &#123;\n    console.log(this.$slots)\n  &#125;,\n  methods: &#123;\n    handlerClick (e) &#123;\n      this.$emit(&#39;click&#39;, e)\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n&lt;style lang&#x3D;&quot;scss&quot;&gt;\n&#x2F;&#x2F; 按钮样式\n .qi-button&#123;\n    display: inline-block;\n    line-height: 1;\n    white-space: nowrap;\n    cursor: pointer;\n    background: #ffffff;\n    border: 1px solid #dcdfe6;\n    color: #606266;\n    -webkit-appearance: none;\n    text-align: center;\n    box-sizing: border-box;\n    outline: none;\n    margin: 0;\n    transition: 0.1s;\n    font-weight: 500;\n    &#x2F;&#x2F;禁止元素的文字被选中\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    padding: 12px 20px;\n    font-size: 14px;\n    border-radius: 4px;\n    &amp;:hover,\n    &amp;:focus&#123;\n      color: #409eff;\n      border-color: #c6e2ff;\n      background-color: #ecf5ff;\n    &#125;\n  &#125;\n  .qi-button-primary&#123;\n  color:#fff;\n  background-color: #409eff;\n  border-color: #409eff;\n  &amp;:hover,\n  &amp;:focus&#123;\n    background: #66b1ff;\n    background-color: #66b1ff;\n    color: #fff;\n    &#125;\n  &#125;\n  .qi-button-success&#123;\n  color:#fff;\n  background-color: #67c23a;\n  border-color: #67c23a;\n  &amp;:hover,\n  &amp;:focus&#123;\n    background: #85ce61;\n    background-color: #85ce61;\n    color: #fff;\n    &#125;\n  &#125;\n  .qi-button-info&#123;\n  color:#fff;\n  background-color: #909399;\n  border-color: #909399;\n  &amp;:hover,\n  &amp;:focus&#123;\n    background: #a6a9ad;\n    background-color: #a6a9ad;\n    color: #fff;\n    &#125;\n  &#125;\n  .qi-button-warning&#123;\n  color:#fff;\n  background-color: #e6a23c;\n  border-color: #e6a23c;\n  &amp;:hover,\n  &amp;:focus&#123;\n    background: #ebb563;\n    background-color: #ebb563;\n    color: #fff;\n    &#125;\n  &#125;\n  .qi-button-danger&#123;\n  color:#fff;\n  background-color: #f56c6c;\n  border-color: #f56c6c;\n  &amp;:hover,\n  &amp;:focus&#123;\n    background: #f78989;\n    background-color: #f78989;\n    color: #fff;\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 朴素按钮样式\n.qi-button.is-plain&#123;\n  &amp;:hover,\n  &amp;:focus&#123;\n    background: #fff;\n    border-color: #489eff;\n    color: #409eff;\n  &#125;\n&#125;\n.qi-button-primary.is-plain&#123;\n  color: #409eff;\n  background: #ecf5ff;\n  &amp;:hover,\n  &amp;:focus&#123;\n    background: #409eff;\n    border-color: #409eff;\n    color: #fff;\n  &#125;\n&#125;\n.qi-button-success.is-plain&#123;\n  color: #67c23a;\n  background: #c2e7b0;\n  &amp;:hover,\n  &amp;:focus&#123;\n    background: #67c23a;\n    border-color: #67c23a;\n    color: #fff;\n  &#125;\n&#125;\n.qi-button-info.is-plain&#123;\n  color: #909399;\n  background: #d3d4d6;\n  &amp;:hover,\n  &amp;:focus&#123;\n    background: #909399;\n    border-color: #909399;\n    color: #fff;\n  &#125;\n&#125;\n.qi-button-warning.is-plain&#123;\n  color: #e6a23c;\n  background: #f5dab1;\n  &amp;:hover,\n  &amp;:focus&#123;\n    background: #e6a23c;\n    border-color: #e6a23c;\n    color: #fff;\n  &#125;\n&#125;\n&#x2F;&#x2F; round\n.qi-button.is-round&#123;\n  border-radius: 20px;\n  padding: 12px 23px;\n&#125;\n&#x2F;&#x2F; 圆形\n\n.qi-button.is-circle&#123;\n  border-radius: 50%;\n  padding: 12px;\n&#125;\n&#x2F;&#x2F; 去除图标相隔太近\n.qi-button [class*&#x3D;qi-icon-]+span&#123;\n  margin-left: 5px;\n&#125;\n&#x2F;&#x2F; 禁用\n.qi-button.is-disabled &#123;\n  cursor: no-drop;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n","slug":"自定义封装ui-button按钮","date":"2022-06-27T03:48:12.000Z","categories_index":"ui库","tags_index":"ui库","author_index":"小提琴"},{"id":"316ea3df3f075543c59a5d1fe255bb06","title":"ReactHooks","content":"ReactHookshooks优点:\n\n高阶组件为了复用，导致代码层级复杂 \n生命周期的复杂 \n写成functional组件,无状态组件 ，因为需要状态，又改成了class,成本高\n不存在生命周期，所以不要把 Class Component 的生命周期概念搬过来试图对号入座\n\n&#x2F;&#x2F; useState保存组件状态\nconst [ state, setstate] &#x3D; useState(initialState)\n\n&#x2F;&#x2F; useEffect处理副作用\nuseEffect( () &#x3D;&gt; &#123;\n  return () &#x3D;&gt; &#123;&#125;\n&#125;,[依赖的状态;空数组表示不依赖])\n&#x2F;&#x2F; 案例\nlet id &#x3D; props.match.params.myid \nuseEffect(()&#x3D;&gt;&#123;    \naxios.get(&#96;&#x2F;articles&#x2F;$&#123;id&#125;&#96;).then(res &#x3D;&gt; &#123;        \nsettitle(res.data.title)        \nsetcontent(res.data.content)        \nsetcategory(res.data.category)   \n&#125;) &#125;,[id])\n&#x2F;*\n简单来说就是调用时机不同， useLayoutEffect 和原来 componentDidMount &amp; componentDidUpdate 一致，在 react完成DOM更新后马上同步调用的代码，会阻塞页面渲染。而 useEffect 是会在整个页面渲染完才会调用的 代码\n*&#x2F;\n&#x2F;*\n在实际使用时如果想避免页面抖动（在 useEffect 里修改DOM很有可能出现）的话，可以把需要操作DOM的代码 放在 useLayoutEffect 里。在这里做点dom操作，这些dom修改会和 react 做出的更改一起被一次性渲染到屏幕 上，只有一次回流、重绘的代价。\n*&#x2F;\n\n&#x2F;&#x2F; useCallback记忆函数\n防止因为组件重新渲染，导致方法被重新创建 ，起到缓存作用; 只有第二个参数 变化了，才重新声明一次\nlet handleClick &#x3D; useCallback( () &#x3D;&gt; \n&#123;    \nconsole.log(name)  \n&#125;,[name])   \n&lt;button onClick&#x3D;&#123;()&#x3D;&gt;handleClick()&#125;&gt;hello&lt;&#x2F;button&gt;    \n&#x2F;&#x2F;只有name改变后， 这个函数才会重新声明一次，   \n&#x2F;&#x2F;如果传入空数组， 那么就是第一次创建后就被缓存， 如果name后期改变了,拿到的还是老的name。  \n&#x2F;&#x2F;如果不传第二个参数，每次都会重新声明一次，拿到的就是最新的name\n\n&#x2F;&#x2F; useMemo 记忆组件\n&#x2F;&#x2F; useCallback 的功能完全可以由 useMemo 所取代\n&#x2F;&#x2F; 如果你想通过使用 useMemo 返回一个记忆函数也是完全可以的。\n&#x2F;* useMemo是针对一个函数，是否多次执行\nuseMemo主要用来解决使用React hooks产生的无用渲染的性能问题\n在方法函数，由于不能使用shouldComponentUpdate处理性能问题，react hooks新增了useMemo\n*&#x2F;\nlet richChild &#x3D; useMemo(() &#x3D;&gt; &#123;\n\t\t&#x2F;&#x2F;执行相应的函数\n\t\treturn getRichChild();\n\t&#125;, [props.name]);\n&#x2F;*\nuseCallback 常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。而 useMemo 更适合经过函数 计算得到一个确定的值，比如记忆组件\n*&#x2F;\n\n&#x2F;&#x2F; useRef保存引用值\nmport React, &#123;useRef&#125; from &quot;react&quot;;\n\nfunction Ref ()&#123;\n    const box &#x3D; useRef()\n\n    return (\n        &lt;div&gt;\n            &lt;div ref&#x3D;&#123;box&#125;&gt;useRef&lt;&#x2F;div&gt;\n            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; console.log(box)&#125;&gt;+1&lt;&#x2F;button&gt;\n        &lt;&#x2F;div&gt;\n    )\n&#125;\nexport default Ref;\n&#x2F;*\n 当我们需要获取元素对象的时候， 首先引入useRef， 其次调用useRef（）方法接收它的返回值，我们需要获取那个DOM元素就在那个DOM元素上进行绑定，通过ref属性将useRef的返回值绑定到元素身上，这样useRef的返回值，通过useRef返回一个对象，对象内部有个current属性，这个属性就对应着我们需要的元素对象；\n*&#x2F;\nimport React, &#123;useRef, useEffect, useState&#125; from &quot;react&quot;;\n\nfunction Ref ()&#123;\n    let timerId &#x3D; useRef()\n    const [count, setCount] &#x3D; useState(0)\n    useEffect(() &#x3D;&gt; &#123;\n        timerId.current &#x3D; setInterval(() &#x3D;&gt; &#123;\n            setCount(count &#x3D;&gt; count + 1)\n        &#125;, 1000)\n    &#125;, [])\n    const stop &#x3D; () &#x3D;&gt; &#123;\n        console.log(timerId)\n        clearInterval(timerId.current)\n    &#125;\n    return (\n        &lt;div&gt;\n            &lt;div&gt;&#123;count&#125;&lt;&#x2F;div&gt;\n            &lt;button onClick&#x3D;&#123;stop&#125;&gt;停止&lt;&#x2F;button&gt;\n        &lt;&#x2F;div&gt;\n    )\n&#125;\nexport default Ref;\n\n&#x2F;&#x2F;useReducer和useContext减少组件层级\nimport React, &#123; useContext, useReducer &#125; from &#39;react&#39;\n\nconst intialState &#x3D; &#123;\n  a: 1,\n  b: 1\n&#125;\nconst reducer &#x3D; (preState, action) &#x3D;&gt; &#123;\n  let newState &#x3D; &#123;...preState&#125;\n  switch(action.type)&#123;\n    case &#39;add1&#39;:\n        newState.a &#x3D; action.value\n        return newState\n    case &#39;add2&#39;:\n        newState.b++\n        return newState\n    default:\n        return preState\n  &#125;\n&#125;\nconst GlobalContext &#x3D; React.createContext()\nexport default function App() &#123;\n  const [state, dispatch] &#x3D; useReducer(reducer,intialState)\n  return (\n    &lt;GlobalContext.Provider value&#x3D;&#123;\n      &#123;\n        state,\n        dispatch\n      &#125; \n    &#125;&gt;\n    &lt;div&gt;\n      &lt;Chilren01&gt;\n        \n      &lt;&#x2F;Chilren01&gt;\n      &lt;Chilren02 &gt;\n        \n      &lt;&#x2F;Chilren02&gt;\n      &lt;Chilren03 &gt;\n\n      &lt;&#x2F;Chilren03&gt;\n    &lt;&#x2F;div&gt;\n    &lt;&#x2F;GlobalContext.Provider&gt;\n  )\n&#125;\nfunction Chilren01()&#123;\n  const &#123; dispatch &#125; &#x3D; useContext(GlobalContext)\n  return (\n    &lt;div&gt;\n        &lt;button onClick&#x3D;&#123;\n           () &#x3D;&gt; &#123;\n            dispatch(&#123;\n                type: &#39;add1&#39;,\n                value: 222222\n              &#125;)\n           &#125;\n        &#125;&gt;改变a&lt;&#x2F;button&gt;\n        &lt;button \n        onClick&#x3D;&#123;\n           () &#x3D;&gt; &#123;\n            dispatch(&#123;\n                type: &#39;add2&#39;\n              &#125;)\n           &#125;\n            &#125;&gt;改变b&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  )\n&#125;\nfunction Chilren02()&#123;\n    const &#123; state &#125; &#x3D; useContext(GlobalContext)\n  return (\n    &lt;div style&#x3D;&#123;&#123;background: &#39;gray&#39;&#125;&#125;&gt;\n        &lt;span&gt;\n            &#123;state.a&#125;\n        &lt;&#x2F;span&gt;\n    &lt;&#x2F;div&gt;\n  )\n&#125;\nfunction Chilren03()&#123;\n    const &#123; state &#125; &#x3D; useContext(GlobalContext)\n  return (\n    &lt;div style&#x3D;&#123;&#123;background: &#39;pink&#39;&#125;&#125;&gt;\n      &lt;span&gt;\n        &#123;state.b&#125;\n      &lt;&#x2F;span&gt;\n    &lt;&#x2F;div&gt;\n  )\n&#125;\n\n\n\n\n\n\n\n\n\n\n自定义hooks\n当我们想在两个函数之间共享逻辑时，我们会把它提取到第三个函数中。必须以“use”开头吗？必须如此。这个约定非常重要。不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了 Hook 的规则\n","slug":"ReactHooks","date":"2022-06-13T14:29:12.000Z","categories_index":"技术","tags_index":"ES6,JavaScript,React","author_index":"小提琴"},{"id":"e9ee661d319ac0e21c172e3d1f135c82","title":"发布订阅模式","content":"发布订阅模式什么是发布消息订阅模式?\n基于一个事件通道\n希望接收通知的对象A通过自定义事件订阅主题\n被激活事件的对象B通过发布主题事件的方式通知各个订阅该主题的A对象\nclass Observer &#123;\n   constructor()&#123;\n     &#x2F;&#x2F; 事件中心\n     &#x2F;&#x2F; 存储方式为： &#123;a: [], b: []&#125;\n     &#x2F;&#x2F; 每个任务下存放其订阅者事件\n     this.message &#x3D; &#123;&#125;\n   &#125;\n   &#x2F;&#x2F;订阅方法\n   $on(type, fn)&#123;\n     &#x2F;&#x2F; 如果没有订阅消息就初始化一个数组\n     if(!this.message[type])&#123;\n       this.message[type] &#x3D; []\n     &#125;\n     &#x2F;&#x2F; 有订阅消息就push到订阅者事件数组里\n     this.message[type].push(fn)\n   &#125;\n   &#x2F;&#x2F; 取消订阅\n   $off(type, fn)&#123;\n     &#x2F;&#x2F; 判断你有没有订阅\n     if(!this.message[type]) return \n     &#x2F;&#x2F; 判断有没有在订阅者事件队列中没有就删除队列\n     if(!fn)&#123;\n       this.message[type] &#x3D; undefined\n     &#125;\n     &#x2F;&#x2F; 如果存在订阅者事件就过滤掉它\n     this.message[type] &#x3D; this.message[type].filter(item &#x3D;&gt; item !&#x3D;&#x3D; fn)\n   &#125;\n   &#x2F;&#x2F; 发送消息\n   $emit(type)&#123;\n     if(!this.message[type]) return &#39;没有找到该消息&#39;\n     this.message[type].forEach(item &#x3D;&gt; item() )\n   &#125;\n &#125;\n &#x2F;&#x2F; 发布者\n const person1 &#x3D; new Observer()\n &#x2F;&#x2F; 订阅一下内容\n  person1.$on(&#39;abc&#39;, handleClickA)\n  person1.$on(&#39;quit&#39;,handleClickB)\n  person1.$on(&#39;uuid&#39;,handleClickC)\n  person1.$off(&#39;abc&#39;,handleClickA)\n  person1.$emit(&#39;abc&#39;)\n  person1.$emit(&#39;quit&#39;)\n  person1.$emit(&#39;uuid&#39;)\n  function handleClickA()&#123;\n    console.log(1111)\n  &#125;\n  function handleClickB()&#123;\n    console.log(2222)\n  &#125;\n  function handleClickC()&#123;\n    console.log(3333)\n  &#125;\n\n","slug":"发布订阅模式","date":"2022-06-13T14:29:12.000Z","categories_index":"技术","tags_index":"ES6,JavaScript","author_index":"小提琴"},{"id":"cc519f18fc7027e7d44b9a0621d59e8e","title":"小程序","content":"小程序分享朋友圈功能小程序页面默认不可被分享到朋友圈，开发者需主动设置“分享到朋友圈”。页面允许被分享到朋友圈，需满足两个条件：\n\n首先，页面需设置允许“发送给朋友”。具体参考 Page.onShareAppMessage 接口文档\n满足条件 1 后，页面需设置允许“分享到朋友圈”，同时可自定义标题、分享图等。具体参考 Page.onShareTimeline 接口文档\n\nshowShareMenu\n支持快速分享到朋友圈使用默认小程序标题，分享图为小程序logo，不可自定义参数\nuni.showShareMenu(&#123;\n  menus: [&#39;shareAppMessage&#39;, &#39;shareTimeline&#39;] &#x2F;&#x2F;shareAppMessage必须得有\n&#125;)\n\nonShareTimeline\n支持自定义分享到朋友圈的小程序标题、分享图，自定义query参数\n&#x2F;&#x2F;注意必须得设置允许“发送给朋友”onShareAppMessage，是设置onShareTimeline的前提，否则不支持分享到朋友圈\nonShareAppMessage: () &#x3D;&gt; &#123;\n&#125;,\nonShareTimeline: () &#x3D;&gt; &#123;\n  return &#123;\n    title: &quot;测试小程序朋友圈分享&quot;,\n    query: &quot;id&#x3D;110101&amp;name&#x3D;heyzqt&quot;,\n    imageUrl: &quot;https:&#x2F;&#x2F;example.cn&#x2F;test.png&quot;\n  &#125;\n&#125;,\n\n","slug":"小程序分享朋友圈功能","date":"2022-06-12T13:44:15.000Z","categories_index":"技术","tags_index":"小程序","author_index":"小提琴"},{"id":"8c91c7fcf700c42b838e9d1e512a6e9a","title":"Vue自定义指令","content":"Vue自定义指令Vue自定义指令有全局注册和局部注册两种方式\n全局注册通过Vue.directive(id,[definition])\n局部注册通过directives注册指令\n&#x2F;&#x2F; 全局注册\n&#x2F;&#x2F; src&#x2F;main.js\nimport Vue from &quot;vue&quot;;\nimport App from &quot;.&#x2F;App.vue&quot;;\n\nVue.config.productionTip &#x3D; false;\nVue.directive(&quot;resize&quot;, &#123;\n  bind() &#123;&#125;,\n  inserted() &#123;&#125;,\n  update() &#123;&#125;,\n  componentUpdated() &#123;&#125;,\n  unbind() &#123;&#125;,\n&#125;);\nnew Vue(&#123;\n  render: (h) &#x3D;&gt; h(App),\n&#125;).$mount(&quot;#app&quot;);\n&#x2F;&#x2F;局部注册\n&lt;script&gt;\nexport default &#123;\n  name: &quot;App&quot;,\n  components: &#123;&#125;,\n  directives: &#123;\n    resize: &#123;\n      bind() &#123;&#125;,\n      inserted() &#123;&#125;,\n      update() &#123;&#125;,\n      componentUpdated() &#123;&#125;,\n      unbind() &#123;&#125;,\n    &#125;,\n  &#125;,\n&#125;;\n&lt;&#x2F;script&gt;\n\n钩子函数bind:只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置\ninserted:被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。\nupdate:所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新\ncomponentUpdated:指令所在组件的 VNode及其子 VNode全部更新后调用。\nunbind:只调用一次，指令与元素解绑时调用。\n简单理解钩子函数顺序：指令绑定到元素时（bind）、元素插入时（inserted）、组件更新时（update）、组件更新后（componentUpdated）、指令与元素解绑时（unbind）\n钩子函数参数el:指令所绑定的元素，可以用来直接操作 DOM。\nbinding:一个对象，包含以下属性\n\nname：指令名，不包括 v- 前缀。\nvalue：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。\noldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。\nexpression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。\narg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。\nmodifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar中，修饰符对象为{ foo: true, bar: true }\n\nvnode:Vue 编译生成的虚拟节点。\noldVnode:上一个虚拟节点，仅在update和componentUpdated钩子中可用。\n","slug":"Vue自定义指令","date":"2022-06-12T13:21:42.000Z","categories_index":"技术","tags_index":"ES6,JavaScript,vue","author_index":"小提琴"},{"id":"172b888c0dcd8e362469b61e697dea6a","title":"vue权限","content":"vue权限什么是权限权限是对特定资源访问,也就是确保用户只能访问到被分配的资源\n前端发起的请求都会触发路由和视图\n可以从路由和视图方面进行控制\n\n路由方面:用户登录后只能看到自己有权访问的菜单导航\n视图方面: 用户只能看到自己有权浏览的内容和控件\n\n前端权限控制分为四个方面:\n\n接口权限\n按钮权限\n菜单权限\n路由权限\n\n接口权限接口权限一般采用jwt的形式验证,没有通过的话返回401,跳转到登录页面重新登录\n登录完成拿到token,将token存起来通过axios请求拦截器进行拦截,每次请求的时候请求头携带token\n菜单权限菜单与路由分离,菜单由后端返回\n&#x2F;&#x2F; 引入vuex vue vuerouter 菜单接口\nimport Vue from &#39;vue&#39;\nimport VueRouter from &#39;vue-router&#39;\nimport &#123; getData &#125; from &#39;@&#x2F;utils&#x2F;api.js&#39;\nimport store from &#39;@&#x2F;store&#x2F;index.js&#39;\n&#x2F;&#x2F; 挂载到vue上\nVue.use(VueRouter)\n&#x2F;&#x2F; 定义路由配置\nconst routes &#x3D; [\n  &#123;\n    path: &#39;&#x2F;&#39;,\n    component: () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &#39;..&#x2F;views&#x2F;home.vue&#39;)\n  &#125;,\n]\n&#x2F;&#x2F; 动态生成数据\n&#x2F;&#x2F; arr.forEach(item &#x3D;&gt; &#123;\n&#x2F;&#x2F;   routes.push(&#123;\n&#x2F;&#x2F;     path: item.path,\n&#x2F;&#x2F;     name: item.name,\n&#x2F;&#x2F;     meta: &#123; title: item.title &#125;,\n&#x2F;&#x2F;     component: () &#x3D;&gt; import(&#96;..&#x2F;views&#x2F;rightMain&#x2F;content&#x2F;$&#123;item.component&#125;&#96;)\n&#x2F;&#x2F;   &#125;)\n&#x2F;&#x2F; &#125;)\n&#x2F;&#x2F; 声明路由器\nconst router &#x3D; new VueRouter(&#123;\n  routes\n&#125;)\n&#x2F;&#x2F;路由前置守卫\nrouter.beforeEach(async(to, from, next) &#x3D;&gt; &#123;\n  &#x2F;* 由于每次点击页面菜单是都会向后台发起请求\n    为减少页面开销,将登录成功后后端返回的路由菜单存在vuex缓存中\n    让页面点击时不用每次都请求一次,减少不必要的操作\n  *&#x2F;\n  &#x2F;&#x2F; 判断vuex是否存在数据 存在放行 不存在获取数据\n  if(store &amp;&amp; store.state.nav.length &#x3D;&#x3D;&#x3D; 0)&#123;\n  &#x2F;&#x2F; 获取数据\n  let &#123; menuData &#125;  &#x3D; await getData().then(res &#x3D;&gt; res.data.Data)\n  &#x2F;&#x2F; 数据缓存\n  store.dispatch(&#39;SETNAV&#39;,menuData)\n  &#x2F;&#x2F; 处理路由配置\n  let routerConfig &#x3D; addmyRoute(menuData)\n  &#x2F;&#x2F; 动态添加路由\n  router.addRoutes(routerConfig)\n  &#x2F;&#x2F; 进行跳转\n  next(&#123;path: to.path&#125;)\n  &#125; else &#123;\n    next()\n  &#125;\n&#125;)\nfunction addmyRoute(menuData)&#123;\n  console.log(menuData)\n  menuData.forEach(item &#x3D;&gt; &#123;\n  routes.push(&#123;\n    path: item.path,\n    name: item.name,\n    &#x2F;&#x2F; meta: &#123; title: item.title &#125;,\n    component: () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &#96;..&#x2F;views&#x2F;$&#123;item.component&#125;.vue&#96;)\n  &#125;)\n&#125;)\nreturn routes\n&#125;\nexport default router\n\n\n&#x2F;&#x2F; vuex部分\nimport Vue from &#39;vue&#39;\nimport Vuex from &#39;vuex&#39;\n\nVue.use(Vuex)\n\nexport default new Vuex.Store(&#123;\n  state: &#123;\n    nav: []\n  &#125;,\n  getters:&#123;\n    navData: state &#x3D;&gt; state.nav\n  &#125;,\n  mutations: &#123;\n    SETNAV(state,data)&#123;\n      state.nav &#x3D; data\n    &#125;\n  &#125;,\n  actions: &#123;\n    SETNAV(&#123;commit&#125;, data)&#123;\n      commit(&#39;SETNAV&#39;,data)\n    &#125;\n  &#125;,\n  modules: &#123;\n  &#125;\n&#125;)\n---------------------------\n&#x2F;&#x2F; 当登录成功后可以将菜单存储在vuex中\nasync getNav()&#123;\n    let &#123; data &#125; &#x3D; await getData()\n      this.$store.dispatch(&#39;SETNAV&#39;,data.list)\n &#125;\n---------------------------\n&#x2F;&#x2F; 请求拦截器 响应拦截器\nimport axios from &#39;axios&#39;\naxios.defaults.baseURL &#x3D; &#39;http:&#x2F;&#x2F;localhost:9999&#x2F;&#39;\n&#x2F;&#x2F; 请求拦截器\naxios.interceptors.request.use(config &#x3D;&gt; config)\n&#x2F;&#x2F;响应拦截器\naxios.interceptors.response.use(res &#x3D;&gt; &#123;\n  return res\n&#125;, err &#x3D;&gt; &#123;\n  return Promise.reject(err)\n&#125;)\nexport default axios\n\n","slug":"vue权限","date":"2022-06-12T13:21:42.000Z","categories_index":"技术","tags_index":"ES6,JavaScript,vue","author_index":"小提琴"},{"id":"6cd9e1bb9bbadb00218cbfbe2f652058","title":"watch监听器","content":"watch监听器监听简单数据类型data()&#123;\n  return&#123;\n    name: &#39;张三&#39;\n  &#125;\n&#125;\nwatch: &#123;\n  name(val)&#123;\n    console.log(val)\n  &#125;\n&#125;\n\n监听复杂数据类型data()&#123;\n  return&#123;\n    obj: &#123;\n      name: &#39;张三&#39;,\n      age： 18\n    &#125;\n  &#125;\n&#125;\nwatch: &#123;\n  obj: &#123;\n    immediate: true &#x2F;&#x2F; watch首次绑定时监听 默认false不监听\n    deep: true &#x2F;&#x2F; 深度监听 默认false不开启深度监听\n    handler(val)&#123;  &#x2F;&#x2F;  handler函数不能为箭头函数,this会取上下文\n    &#x2F;&#x2F;深度监听必须为hander否着不生效\n      console.log(val)\n    &#125;\n  &#125;\n&#125;\n\n监听对象某个属性data()&#123;\n  return&#123;\n    obj: &#123;\n      name: &#39;张三&#39;,\n      age： 18\n    &#125;\n  &#125;\n&#125;\nwatch: &#123;\n  &#39;obj.name&#39;(val)&#123;\n    console.log(val)\n  &#125;\n&#125;\n\n","slug":"watch监听器","date":"2022-06-12T13:21:42.000Z","categories_index":"技术","tags_index":"ES6,JavaScript,vue","author_index":"小提琴"},{"id":"33876cf3e210da358d8e4b065eea88e6","title":"axios","content":"请求拦截器响应拦截器axios有两种拦截器分别为请求拦截器和响应拦截器\n请求拦截器:\n\n在向后台发起请求时进行必要处理操作\n运用场景如,添加统一cookie,请求体加验证,设置请求头\n等同于每个请求都做了相同操作\n\n响应拦截器:\n\n请求得到响应后对响应体做一些处理\n运用场景如: 判断登录失效,token过期等,数据统一处理\n\n&#x2F;&#x2F; axios创建 \n&#x2F;&#x2F; 下载axios npm i axios\n&#x2F;&#x2F; 引入axios\nimport axios from &#39;axios&#39;\n&#x2F;&#x2F; 创建实例\n const request &#x3D; axios.create(&#123;\n  baseURL: &#39;后台服务器地址&#39;,\n  timeout: 20000 &#x2F;&#x2F; 请求最多多少时间\n&#125;)\n\n&#x2F;&#x2F; 请求拦截器\naxios.interceptors.request.use(request &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 在发起请求前需要做那些事\n  return request\n&#125;, err &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 请求错误时要做哪些事\n  return Promise.reject(err)\n&#125;)\n&#x2F;&#x2F; 响应拦截器\naxios.interceptors,reponse.use(reponse &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 响应成功时\n  return reponse\n&#125;, err &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 响应失败时\n  return Promise.reject(err).\n&#125;)\n\n&#x2F;&#x2F; 案例\n&#x2F;&#x2F; 请求拦截器\naxios.interceptors.request.use(req &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 给请求头设置token\n  req.headers.Authorization &#x3D; store.state.token\n  return req\n&#125;, err &#x3D;&gt; &#123;\n  return Promise.reject(err)\n&#125;)\n&#x2F;&#x2F; 响应拦截器\naxios.interceptors.response.use( res &#x3D;&gt; &#123;\n  return res \n&#125;, err &#x3D;&gt; &#123;\n&#x2F;&#x2F; 当token失效时 清空token 并跳转到首页\n  if(err.res.status &#x3D;&#x3D;&#x3D; 401)&#123;\n    store.commit(&#39;token&#39;, &#39;&#39;)\n    router.push(&#39;&#x2F;login&#39;)\n  &#125;\n  return Promise.reject(err)\n&#125;)\n\n","slug":"请求拦截器响应拦截器","date":"2022-06-12T13:21:42.000Z","categories_index":"技术","tags_index":"axios","author_index":"小提琴"},{"id":"0cc9f247ec8cd6a003267063f354c1c2","title":"React基础","content":"React基础react安装npm install -g create-react-app &#x2F;&#x2F; 全局安装\n\n创建一个项目create-react-app 项目名\n\n不想全局安装可以使用npx方式npx create-react-app 项目名\n&#x2F;&#x2F; 需要等待一段时间,在等待时间内实际是安装react库\n&#x2F;&#x2F; react: react顶级库\n&#x2F;&#x2F; react-dom: web的react运行环境 比如app端的react-native\n&#x2F;&#x2F; react-scripts: 包含运行和打包react应用程序的所有脚本配置\n&#x2F;&#x2F; 安装成功后会生成如下的目录结构\n|-- README.md 使用方法的文档\n|-- node_modules 所有依赖安装的目录\n|-- package-lock.json 锁定安装时包的版本号，确保多人开发时依赖能保持一致\n|-- package.json 下载的安装包插件\n|-- public  静态资源公共目录\n|-- src 源代码目录\n\nnpm安装失败\n切换npm镜像源\n使用yarn安装\n删除node_modules及package-lock.json重新执行 npm install\n清除npm缓存 npm cache clean --force 再执行 npm install\n\nreact基本结构&#x2F;&#x2F; 从react的包当中引入react,只要写react.js组件就必须引入\nimport React from &#39;react&#39;\n&#x2F;&#x2F; react-dom可以把组件渲染到web页面\nimport ReactDOM from &#39;react-dom&#39;\n&#x2F;&#x2F; react-dom中有一个render方法,负责将组件渲染与构造dom树,然后插入到页面元素上\nReactDOM.render(&#39;组件名&#39;,document.getElementById(&#39;挂载的页面id节点&#39;))\n\n\nJSX语法\nJSX将HTMl语法直接加入到JavaScript代码中\n由Babel的JSX编译器实现\n通过编译时会转换为纯JavaScript\n\nJSX原理&#x2F;&#x2F; 要明白JSX的原理，需要先明白如何用 JavaScript 对象来表现一个 DOM 元素的结构? \n&#x2F;&#x2F;基本结构\ndiv class&#x3D;&#39;app&#39; id&#x3D;&#39;appRoot&#39;&gt;  \n&lt;h1 class&#x3D;&#39;title&#39;&gt;欢迎进入React的世界&lt;&#x2F;h1&gt; \n&lt;p&gt;    \nReact.js 是一个帮助你构建页面 UI 的库  \n&#x2F;p&gt; \n&lt;&#x2F;div&gt; \n&#x2F;&#x2F; 使用JavaScript对象\n&#123;  tag: &#39;div&#39;,\nattrs: &#123; className: &#39;app&#39;, id: &#39;appRoot&#39;&#125;,  \nchildren: [    \n&#123; tag: &#39;h1&#39;, \nattrs: &#123; className: &#39;title&#39; &#125;,\nchildren: [&#39;欢迎进入React的世界&#39;] &#125;, \n&#123;  \n  tag: &#39;p&#39;, \n  attrs: null, \n  children: [&#39;React.js 是一个构建页面 UI 的库&#39;]    \n  &#125;  \n  ] \n &#125;\n &#x2F;*\nJavaScript 写起来太长了，结构看起来又不清晰，用 HTML 的方式写起来就方便很多了\n React.js 就把 JavaScript 的语法扩展了一下\n 让 JavaScript 语言能够支持这种直接在 JavaScript 代码里面编写类似 HTML 标签结构的语法\n 编译的过程会把类似 HTML 的 JSX 结构转换成 JavaScript 的对象结构\n*&#x2F;\n&#x2F;&#x2F; react编译前代码\nimport React from &#39;react&#39; \nimport ReactDOM from &#39;react-dom&#39;\nclass App extends React.Component &#123; \n  render () &#123;\n    return (\n      &lt;div className&#x3D;&#39;app&#39; id&#x3D;&#39;appRoot&#39;&gt; \n      &lt;h1 className&#x3D;&#39;title&#39;&gt;欢迎进入React的世界&lt;&#x2F;h1&gt;\n      &lt;p&gt;\n      React.js 是一个构建页面 UI 的库\n      &lt;&#x2F;p&gt;\n      &lt;&#x2F;div&gt; \n      ) \n      &#125; \n     &#125;\nReactDOM.render(    &lt;App &#x2F;&gt;,  document.getElementById(&#39;root&#39;) )\n&#x2F;&#x2F; react编译后代码\nimport React from &#39;react&#39; \nimport ReactDOM from &#39;react-dom&#39;\nclass App extends React.Component &#123;  \n  render () &#123;\n    return (\n      React.createElement(\n      &quot;div&quot;,\n      &#123; \n        assName: &#39;app&#39;,\n        id: &#39;appRoot&#39;\n      &#125;,\n      React.createElement(&quot;h1&quot;, \n      &#123; \n      className: &#39;title&#39; \n      &#125;,          \n      &quot;欢迎进入React的世界&quot;        \n      ),        \n      React.createElement(&quot;p&quot;,\n                           null,          \n                           &quot;React.js 是一个构建页面 UI 的库&quot;        \n                           )      \n                         )    \n                       )  \n                     &#125; \n                   &#125;\nReactDOM.render(    React.createElement(App),  document.getElementById(&#39;root&#39;) )\n&#x2F;&#x2F; React.createElement会构建一个 JavaScript 对象来描述你 HTML 结构的信息，包括标签名、属性、 还有子元素等, 语法为\n&#x2F;&#x2F; 编译顺序 JSX —使用react构造组件，bable进行编译—&gt; JavaScript对象 — ReactDOM.render() —&gt;DOM 元素 —&gt;插入页面\n\nclass组件&#x2F;&#x2F; es6 class组件其实就是一个构造器,每次使用组件都相当于实列化组件\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\nclass App extends React.Component &#123;  \n  render () &#123;    \n    return (          \n      &lt;h1&gt;欢迎进入React的世界&lt;&#x2F;h1&gt;    \n    )  \n  &#125; \n&#125; \n&#x2F;*\nconst app &#x3D; new App(&#123;\n  name: &#39;react&#39;\n&#125;).render()\n*&#x2F;\nReactDOM.render(  &lt;App&#x2F;&gt;,  document.getElementById(&#39;root&#39;) )\n\n函数式组件import React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\n&#x2F;&#x2F; 函数式组件 组件名必须大写\nconst App &#x3D; () &#x3D;&gt; &lt;h1&gt;欢迎进入React的世界&lt;&#x2F;h1&gt; \n\nReactDOM.render(\n  &lt;App&#x2F;&gt;\n  document.getElementById(&#39;root&#39;)\n)\n\n组件样式&#x2F;&#x2F; react中给虚拟dom添加行内样式,需要使用表达式传入样式对象的方式实现\nconst App &#x3D; () &#x3D;&gt; &lt;h1 style&#x3D;&#123;&#123;color: &#39;red&#39;，fontSize: &#39;14px&#39;&#125;&#125;&gt;\n欢迎进入React的世界\n&lt;&#x2F;h1&gt;\n&#x2F;&#x2F; 给元素添加类名\nconst App &#x3D; () &#x3D;&gt; &lt;h1 clssName&#x3D;&quot;styleName&quot;&gt;\n欢迎进入React的世界\n&lt;&#x2F;h1&gt;\n&#x2F;&#x2F; 由于css的class样式跟js的class同名因而发起冲突因此react中class为className\n&#x2F;&#x2F; label中的for为htmlFor\n&#x2F;&#x2F; class &#x3D;&#x3D;&gt; className for &#x3D;&#x3D;&gt; htmlFor(label)\n\n事件绑定\nreact事件采用 on+事件名方式绑定\nreact的事件是以驼峰命名显示onClick\nreact的事件并不是原生事件,而是合成事件\n\n因为this指向与函数执行的原因因此&#x2F;&#x2F;react推荐在组件内使用箭头函数定义一个方法\nconst App &#x3D; () &#x3D;&gt; &lt;h1 clssName&#x3D;&quot;styleName&quot; onClick&#x3D;&#123; handlerClick() &#125;&gt;\nhandlerClick &#x3D; () &#x3D;&gt; &#123;\n console.log(123)\n&#125;\nconst App &#x3D; () &#x3D;&gt; &lt;h1 clssName&#x3D;&quot;styleName&quot; onClick&#x3D;&#123; this.handlerClick  &#125;&gt;\nhandlerClick()&#123;\n console.log(123)\n&#125;\n&#x2F;*react不推荐\n直接在组件内定义一个非箭头函数方法,然后render里直接使用onClick&#x3D;&#123;this.handlerClick.bind(this)&#125;\n*&#x2F;\n&#x2F;&#x2F;直接在render里写行内的箭头函数(不推荐) \nconst App &#x3D; () &#x3D;&gt; &lt;h1 clssName&#x3D;&quot;styleName&quot; onClick&#x3D;&#123; () &#x3D;&gt; &#123; this.handlerClick() &#125; &#125;&gt;\nhandlerClick()&#123;\n console.log(123)\n&#125;\n\nEvent对象和普通浏览器一样，事件handler会被自动传入一个 event 对象，这个对象和普通的浏览器 event 对 象所包含的方法和属性都基本一致。不同的是 React中的 event 对象并不是浏览器提供的，而是它自 己内部所构建的。它同样具有 event.stopPropagation 、 event.preventDefault 这种常用的方法\nRef应用&#x2F;&#x2F; 给标签设置ref\nmyRef &#x3D; React.createRef() &#x2F;&#x2F; 创建ref\n    &lt;div&gt;\n        &lt;input type&#x3D;&#39;text&#39; ref&#x3D;&#123;this.myRef&#125;&gt;&lt;&#x2F;input&gt; &#x2F;&#x2F; 引用ref\n        &lt;button onClick&#x3D;&#123; () &#x3D;&gt; &#123;\n          console.log(this.myRef.current.value)\n        &#125;&#125;&gt;点击&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n\n状态(state)状态就是组件描述某种显示情况的数据，由组件自己设置和更改，也就是说由组件自己维护，使用状态 的目的就是为了在不同的状态下使组件的显示不同\n&#x2F;&#x2F; 定义状态的两种方式\nimport React, &#123; Component &#125; from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\n\nclass App extends Component &#123;\n &#x2F;* state &#x3D; &#123;\n    name: &#39;React&#39;,\n    isLiked: false\n  &#125; *&#x2F;\n  constructor()&#123;\n    super()\n    this.state &#x3D; &#123;\n      name: &#39;React&#39;,\n      isLiked: false\n    &#125;\n  &#125;\n  handleBtnClick &#x3D; () &#x3D;&gt; &#123;\n    this.setState(&#123;\n      isLiked: !this.state.isLiked\n    &#125;)\n  &#125;\n  render () &#123;\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;欢迎来到&#123; this.state.name &#125; 的世界&lt;&#x2F;h1&gt;\n        &lt;button onClick&#x3D;&#123;this.handleBtnClick&#125;&gt;\n        &#123;\n          this.state.isLiked ? &#39;取消&#39; : &#39;收藏&#39;\n        &#125;\n        &lt;button&gt;\n      &lt;&#x2F;div&gt;\n    )\n  &#125;\n&#125;\n&#x2F;*this.state 是纯js对象,在vue中，data属性是利用 Object.defineProperty 处理过的，更改 data的 数据的时候会触发数据的 getter 和 setter ，但是React中没有做这样的处理，如果直接更改的话， react是无法得知的，所以，需要使用特殊的更改状态的方法 setState *&#x2F;\n\nsetState有两个参数第一个参数可以是对象,也可以是方法return一个对象\n&#x2F;&#x2F; 参数是对象\nthis.setState(&#123;\n  isLiked: !this.state.isLiked\n&#125;)\n&#x2F;&#x2F; 参数是方法\nthis.setState((preState, props) &#x3D;&gt; &#123;\n  return &#123;\n    isLiked: !preState.isLiked \n  &#125;\n&#125;)\n&#x2F;*\n注意的是这个方法接收两个参数，第一个是上一次的state, 第二个是props setState 是异步的，所以想要获取到新的state，没有办法获取，就有了第二个参数，这是一个可选 的回调函数\n*&#x2F;\nthis.setState((preState, props) &#x3D;&gt; &#123;\n  return &#123;\n    isLiked: !preState.isLiked\n  &#125;\n&#125;, () &#x3D;&gt; &#123;\n  console.log(&#39;回调里的&#39;,this.state.isLiked)\n&#125; )\n\n属性(props)props 是正常是外部传入的，组件内部也可以通过一些方式来初始化的设置，属性不能被组件自己更 改，但是你可以通过父组件主动重新渲染的方式来传入新的 props属性是描述性质、特点的，组件自己不能随意更改。之前的组件代码里面有 props 的简单使用，总的来说，在使用一个组件的时候，可以把参数放在标签的 属性当中，所有的属性都会作为组件 props 对象的键值。通过箭头函数创建的组件，需要通过函数的 参数来接收 props \n\n在组件上通过key&#x3D;value 写属性,通过this.props获取属性,这样组件的可复用性提高了\n注意在传参数时候，如果写成isShow&#x3D;”true” 那么这是一个字符串    如果写成isShow&#x3D;{true} 这个是布尔值\n{…对象}  展开赋值\n默认属性值\n\n&#x2F;&#x2F; 父组件\nimport React, &#123; Component &#125; from &#39;react&#39;\nimport Navbar from &#39;.&#x2F;Navbar&#x2F;index&#39;\nexport default class App extends Component &#123;\n    state &#x3D; &#123;&#125;\n    render() &#123;\n    return (\n      &lt;div&gt;\n          &lt;div&gt;\n           &lt;h2&gt;首页&lt;&#x2F;h2&gt;\n          &lt;Navbar title&#x3D;&quot;首页&quot; leftShow&#x3D;&#123;false&#125;&#x2F;&gt;\n          &lt;&#x2F;div&gt;\n          &lt;div&gt;\n            &lt;h2&gt;列表&lt;&#x2F;h2&gt;\n            &lt;Navbar title&#x3D;&quot;列表&quot; leftShow&#x3D;&#123;true&#125;&#x2F;&gt;\n          &lt;&#x2F;div&gt;\n          &lt;div&gt;\n            &lt;h2&gt;购物车&lt;&#x2F;h2&gt;\n            &lt;Navbar title&#x3D;&quot;购物车&quot; leftShow&#x3D;&#123;true&#125;&#x2F;&gt;\n          &lt;&#x2F;div&gt;\n      &lt;&#x2F;div&gt;\n    )\n  &#125;\n&#125;\n&#x2F;&#x2F; 子组件\nimport React, &#123; Component &#125; from &#39;react&#39;\nexport default class Navbar extends Component &#123;\n  render() &#123;\n    let &#123; title,leftShow &#125; &#x3D; this.props\n    return (\n      &lt;div&gt;\n          &#123;leftShow &amp;&amp; &lt;button&gt;返回&lt;&#x2F;button&gt;&#125;\n          &#123; title &#125;\n          &lt;button&gt;home&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    )\n  &#125;\n&#125;\n\n\nprop-types属性验证\nimport propTypes from &#39;prop-types&#39; &#x2F;&#x2F; 引入属性验证包\n&#x2F;&#x2F; 需要验证的属性类属性\n*.propTypes &#x3D; &#123;\n  name: propTypes.string,\n  age: propTypes.number\n&#125;\n&#x2F;&#x2F; 在class中写法\nstatic propTypes &#x3D; &#123;\n  myname: propTypes.string,\n   myshow: propTypes.bool\n&#125;\n\n属性与状态相似点：都是纯js对象，都会触发render更新，都具有确定性（状态&#x2F;属性相同，结果相同）\n不同点： \n\n属性能从父组件获取，状态不能 \n属性可以由父组件修改，状态不能 \n属性能在内部设置默认值，状态也可以，设置方式不一样 \n属性不在组件内部修改，状态要在组件内部修改 \n属性能设置子组件初始值，状态不可以 \n属性可以修改子组件的值，状态不可以\n\nstate 的主要作用是用于组件保存、控制、修改自己的可变状态。 state 在组件内部初始化，可以被 组件自身修改，而外部不能访问也不能修改。你可以认为 state 是一个局部的、只能被组件自身控制 的数据源。 state 中状态可以通过 this.setState 方法进行更新， setState 会导致组件的重新渲 染。\nprops 的主要作用是让使用该组件的父组件可以传入参数来配置该组件。它是外部传进来的配置参 数，组件内部无法控制也无法修改。除非外部组件主动传入新的 props ，否则组件的 props 永远保持 不变。\n没有 state 的组件叫无状态组件（stateless component），设置了 state 的叫做有状态组件 （stateful component）。因为状态会带来管理的复杂性，我们尽量多地写无状态组件，尽量少地写有 状态的组件。这样会降低代码维护的难度，也会在一定程度上增强组件的可复用性。\n渲染数据","slug":"React基础","date":"2022-06-07T14:24:09.000Z","categories_index":"技术","tags_index":"React基础","author_index":"小提琴"},{"id":"fa9186e3fcd1aa3f18e4e09eef185770","title":"Minxins","content":"Mixins分发Vue组件复用功能\nmixins是一个js对象,它可以包含我们组件中script的任意选项\n类如: data  components methods created computed 等等\n将组件中共用功能以对象的方式传入mixins选项\n当组件使用mixins对象时所有mixins对象的选项都将被混入该组件\n使用场景当存在多个组件中功能很相近时,就可以利用mixins将公共部分提取出来,通过mixins进行封装\n&#x2F;&#x2F; minxin是一个对象 所以应该以对象的形式来定义minxins可以和vue组件一样定义自身属性\nexport const myMinxins &#x3D; &#123;\n  components:&#123;&#125;,\n  data() &#123;\n      return &#123;\n        \n      &#125;\n  &#125;,\n  create()&#123;&#125;,\n  mounted() &#123;\n     \n  &#125;,\n  computed: &#123;&#125;,\n  methods: &#123;\n  \n  &#125;,\n&#125;\n\nmixins的使用&#x2F;&#x2F; 在需要使用的组件中引入minxins 在mixins配置中使用\n&#x2F;&#x2F; minxins文件夹下minxins.js\n&lt;script&gt;\nimport &#123; myMinxins &#125; from &#39;@&#x2F;minxins&#x2F;minxins&#39;\nexport default &#123;\n  name: &#39;Home&#39;,\n  mixins: [myMinxins]\n&#125;\n&lt;&#x2F;script&gt;\n\n方法和参数在各组件中不共享，虽然组件调用了mixins并将其属性合并到自身组件中来了，但是其属性只会被当前组件所识别并不会被共享，也就是其他组件无法从当前组件中获取到mixins中的数据和方法。\n值为对象(components、methods 、computed、data)的选项，混入组件时选项会被合并，键冲突时优先组件，组件中的键会覆盖混入对象的\n值为函数(created、mounted)的选项，混入组件时选项会被合并调用，混合对象里的钩子函数在组件里的钩子函数之前调用\n与vuex的区别vuex：状态管理机，里面定义的变量在每个组件中均可以使用和修改，在任一组件中修改此变量的值之后，其他组件中此变量的值也会随之修改。\nMixins：可以定义共用的变量，在每个组件中使用，引入组件中之后，各个变量是相互独立的，值的修改在组件中不会相互影响。\n与公共组件的区别组件：在父组件中引入组件，相当于在父组件中给出一片独立的空间供子组件使用，然后根据props来传值，但本质上两者是相对独立的。\nMixins：则是在引入组件之后与组件中的对象和方法进行合并，相当于扩展了父组件的对象与方法，可以理解为形成了一个新的组件。\n","slug":"Mixins","date":"2022-06-06T13:30:11.000Z","categories_index":"技术","tags_index":"Vue,JavaScirpt","author_index":"小提琴"},{"id":"d713623c6bc5472ce6c8f594cc93dd04","title":"JavaScript复习","content":" &#x2F;&#x2F; 数组查找 includes indexOf \n  &#x2F;&#x2F; ** 幂运算  &#x3D;&#x3D;&#x3D; Math.pow()\nconst school &#x3D; &#123;\n       name: &quot;尚硅谷&quot;,\n       cities: [&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;],\n       xueke: [&quot;Java&quot;, &quot;Python&quot;, &quot;CSS&quot;]\n   &#125;\n   console.log(Object.keys(school)) &#x2F;&#x2F; 获得每个对象的键集合成数组\n   console.log(Object.values(school)) &#x2F;&#x2F; 获得每个对象的值集合成数组\n   console.log(Object.entries(school)) &#x2F;&#x2F; 把对象转为二维数组\n   const map &#x3D; new Map(Object.entries(school)) &#x2F;&#x2F; 转为Map结构\n   console.log(map)\n   Object.getOwnPropertyDescriptors(school) &#x2F;&#x2F; 查看对象创建时的内置属性有哪些\n\n &#x2F;&#x2F; trim 清除字符串两边空格 \n  &#x2F;&#x2F; trimStart 清楚字符串左边空格\n  &#x2F;&#x2F; trimEnd 清除字符串右边空格\n&#x2F;&#x2F; flat 将多维数组转化为低维数组 参数为深度 是一个数字\n  &#x2F;* const arr &#x3D; [1,2,3,4,[5,6], [7,8]] *&#x2F;\n  &#x2F;* console.log(arr.flat()) *&#x2F;\n  &#x2F;&#x2F; flatMap 返回的map结果如果是个多维数组可以转化为低维数组\n  const arr1 &#x3D; [1, 2, 3, 4]\n  const result &#x3D; arr1.flatMap( item &#x3D;&gt; [item * 10])\n  console.log(result)\n\n#声明的属性为私有属性\nObject,is() 判断两个值是否相等\n Object.assign(‘合并到的目标对象’, “参数对象1”, “参数对象二”) &#x2F;&#x2F; 对象合并 浅拷贝\nborder-radius: 25px 25px; 如果设置了两个值，第一个用于左上角和右下角，第二个用于右上角和左下角\n box-shadow: 0px 0px 10px #888; 水平阴影 垂直阴影 阴影大小 颜色                                                                         \n","slug":"数组查找 includes indexOf","date":"2022-06-06T13:30:11.000Z","categories_index":"技术","tags_index":"JavaScript复习","author_index":"小提琴"},{"id":"5d40e7fe0c283422ee253e93aca4d4aa","title":"VueRouter","content":"VueRouter路由vue 的一个插件库，专门用来实现SPA 应用\n vue2中使用的是&#x76;&#117;&#101;&#x2d;&#114;&#x6f;&#x75;&#x74;&#x65;&#x72;&#64;&#x33;&#46;&#x78;\n vue3中使用的是&#118;&#x75;&#101;&#x2d;&#114;&#x6f;&#x75;&#116;&#101;&#114;&#64;&#x34;&#46;&#120;\n路由一个路由就是一组映射关系\nkey为路径,value就是一个component或者一个方法\n路由分为前端路由和后端路由\n后端路由是一个方法服务器接收到一个请求时，根据请求路径找到匹配的函数来处理请求，返回响应数据\n前端路由:value 是 component，用于展示页面内容，当浏览器的路径改变时，对应的组件就会显示\n路由下载\n&#x2F;&#x2F; vue2\nnpm i vue-router\n&#x2F;&#x2F; vue3\nnpm i vue-router@next\n\n在vue2中\n\n每个组件都有自己的$route属性，里面存储着自己的路由信息\n整个应用只有一个router，可以通过组件的$router属性获取到\n子路由跳转：&lt;router-link to=&quot;/a/b&quot;&gt;a&lt;/router-link&gt;\n要写（&#x2F;）路径来明确子路由地址\n路由to可以省略&#x2F;默认Vue-router给加上了\n路由跳转可以携带参数一般存放在query或params\n路由的命名可以简化路由的跳转及一些操作\n路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置\n\nimport Vue from &#39;vue&#39; &#x2F;&#x2F; 引入vue\nimport Router from &#39;vue-router&#39; &#x2F;&#x2F; 引入vueRouter\n&#x2F;&#x2F;创建一个路由 配置路由\n&#x2F;&#x2F; 声明一个数组 \nconst routes &#x3D; [\n  &#123;\n    path: &#39;&#x2F;&#39;,\n    name: &#39;Home&#39;,\n    component: () &#x3D;&gt; import(&#39;..&#x2F;view&#x2F;Home.vue&#39;)\n  &#125;\n]\n&#x2F;&#x2F; 挂载到vue上\nVue.use(Router)\n&#x2F;&#x2F; 声明一个路由器并暴露出去\nconst router &#x3D; new Router(&#123;\n  base: &#39;&#x2F;&#39;, &#x2F;&#x2F; 应用的基本路径\n  mode: &#39;&#39;  &#x2F;&#x2F; 路由模式 hash模式 history模式 abstract模式\n  routes\n&#125;)\n\nexport default router\n\n在vue3中\nvue3中使用组合式API(Composition API)\nvue3不在使用newRouter()创建实例而是使用createRouter方法\n路由模式也是分别通过 createWebHistory,createWebHashHistory,createMemoryHistory传递base来创建 \n&#x2F;&#x2F; 使用组合式api方式引入使用的对象方法而不是引入整个包\nimport &#123; createRouter, createWebHistory &#125; from &#39;vue-router&#39;\n\n&#x2F;&#x2F;创建一个路由 配置路由\n&#x2F;&#x2F; 声明一个数组 \nconst routes &#x3D; [\n  &#123;\n    path: &#39;&#x2F;&#39;,\n    name: &#39;Home&#39;,\n   component: () &#x3D;&gt; import(&#39;..&#x2F;view&#x2F;Home.vue&#39;)\n  &#125;,\n]\n&#x2F;&#x2F; 声明一个路由器并暴露出去\nconst router &#x3D; createRouter(&#123;\n  &#x2F;&#x2F; 创建了一个history设置了基本路径\n  history: createWebHistory(process.env.BASE_URL), \n  routes\n&#125;)\n\nexport default router\n\nvue2中路由跳转传参query\n!-- 跳转并携带query参数，to的字符串写法 --&gt;\n&lt;router-link :to&#x3D;&quot;&#x2F;home&#x2F;message&#x2F;detail?id&#x3D;666&amp;title&#x3D;你好&quot;&gt;跳转&lt;&#x2F;router-link&gt;\n\t\t\t\t\n&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;\n&lt;router-link :to&#x3D;&quot;&#123;\n\tpath:&#39;&#x2F;home&#x2F;message&#x2F;detail&#39;,\n\tquery:&#123;\n\t\tid:666,\n        title:&#39;你好&#39;\n\t&#125;\n&#125;&quot;&gt;跳转&lt;&#x2F;router-link&gt;\n\n\n&#x2F;&#x2F; 接收参数\n$route.query.id\n$route.query.title\n\nparams\n&#x2F;&#x2F; 传递参数\n                &lt;!-- 跳转路由并携带params参数，to的对象写法 --&gt;\n                &lt;router-link :to&#x3D;&quot;&#123;\n                    name:&#39;xiangqing&#39;,\n                    params:&#123;\n                        id:m.id,\n                        title:m.title\n                    &#125;\n                &#125;&quot;&gt;\n                    &#123;&#123;m.title&#125;&#125;\n                &lt;&#x2F;router-link&gt;\n                \n               \n &#x2F;&#x2F; 接收参数\n$route.params.id\n$route.params.title\n\n路由跳转的replace方法vue2中\n\n控制路由跳转时操作浏览器历史记录的模式\n\n浏览器的历史记录有两种写入方式：push和replace，其中push是追加历史记录，replace是替换当前记录。路由跳转时候默认为push方式\n\n开启replace模式：&lt;router-link replace ...&gt;News&lt;/router-link&gt;\n\n\n&#x2F;&#x2F; vue2\nthis.$router.push() &#x2F;&#x2F; 跳转路由追加记录\nthis.$router.replace() &#x2F;&#x2F; 跳转路由替换当前记录不追加记录\nthis.$router.forward() &#x2F;&#x2F;前进\nthis.$router.back() &#x2F;&#x2F;后退\nthis.$router.go() &#x2F;&#x2F;可前进也可后退\n\nvue3中\n由于vue3的setup方法没有this,所有不能使用this.$router获取路由对象\nvue3中使用useRouter方法进行跳转\nimport &#123; useRouter &#125; fom vue-router\n\nexport default &#123;\n  setup() &#123;\n    const router &#x3D; useRouter() &#x2F;&#x2F; 声明一个路由\n    router.push() &#x2F;&#x2F; 跳转路由追加记录\n    router.replace() &#x2F;&#x2F; 跳转路由替换当前记录不追加记录\n  &#125;\n&#125;\n\n\n\n缓存路由组件&lt;keep-alive include&#x3D;&quot;&quot;&gt;  &#x2F;&#x2F;include中写想要缓存的组件名，不写表示全部缓存\n\t\t\t\t&lt;router-view&gt;&lt;&#x2F;router-view&gt;\n&lt;&#x2F;keep-alive&gt;\n\n让不展示的路由组件保持挂载，不被销毁\nactivated和deactivated是路由组件所独有的两个钩子，用于捕获路由组件的激活状态\n\nactivated路由组件被激活时触发\ndeactivated&#96;路由组件失活时触发\n\nactivated()&#123;\n           console.log(&#39;News组件被激活了&#39;)\n           this.timer &#x3D; setInterval(() &#x3D;&gt; &#123;\n               this.opacity -&#x3D; 0.01\n               if(this.opacity &lt;&#x3D; 0) this.opacity &#x3D; 1\n           &#125;,16)\n       &#125;,\n       deactivated()&#123;\n           console.log(&#39;News组件失活了&#39;)\n           clearInterval(this.timer)\n       &#125;\n\n全局路由守卫&#x2F;&#x2F;全局前置路由守卫————初始化的时候、每次路由切换之前被调用\nrouter.beforeEach((to,from,next) &#x3D;&gt; &#123;\n    console.log(&#39;前置路由守卫&#39;,to,from)\n    if(to.meta.isAuth)&#123;\n        if(localStorage.getItem(&#39;school&#39;)&#x3D;&#x3D;&#x3D;&#39;atguigu&#39;)&#123;\n            next()\n        &#125;else&#123;\n            alert(&#39;学校名不对，无权限查看！&#39;)\n        &#125;\n    &#125;else&#123;\n        next()\n    &#125;\n&#125;)\n\n&#x2F;&#x2F;全局后置路由守卫————初始化的时候被调用、每次路由切换之后被调用\nrouter.afterEach((to,from)&#x3D;&gt;&#123;\n\tconsole.log(&#39;后置路由守卫&#39;,to,from)\n\tdocument.title &#x3D; to.meta.title || &#39;硅谷系统&#39;\n&#125;)\n&#x2F;&#x2F;独享守卫，特定路由切换之后被调用\n                    beforeEnter(to,from,next)&#123;\n                        console.log(&#39;独享路由守卫&#39;,to,from)\n                        if(localStorage.getItem(&#39;school&#39;) &#x3D;&#x3D;&#x3D; &#39;atguigu&#39;)&#123;\n                            next()\n                        &#125;else&#123;\n                            alert(&#39;暂无权限查看&#39;)\n                        &#125;\n                    &#125;\n &#x2F;&#x2F;通过路由规则，离开该组件时被调用\n        beforeRouteEnter (to, from, next) &#123;\n            console.log(&#39;About--beforeRouteEnter&#39;,to,from)\n            if(localStorage.getItem(&#39;school&#39;)&#x3D;&#x3D;&#x3D;&#39;atguigu&#39;)&#123;\n                next()\n            &#125;else&#123;\n                alert(&#39;学校名不对，无权限查看！&#39;)\n            &#125;\n        &#125;,\n        &#x2F;&#x2F;通过路由规则，离开该组件时被调用\n        beforeRouteLeave (to, from, next) &#123;\n            console.log(&#39;About--beforeRouteLeave&#39;,to,from)\n            next()\n        &#125;\n\n对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值\nhash值不会包含在 HTTP 请求中，即：hash值不会带给服务器\nhash模式：\n地址中永远带着#号，不美观若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法兼容性较好history模式：\n地址干净，美观兼容性和hash模式相比略差应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题\n默认路由地址重定向","slug":"VueRouter路由","date":"2022-05-16T12:46:25.000Z","categories_index":"技术","tags_index":"Vue,JavaScript","author_index":"小提琴"},{"id":"b468f3c3ac71ea2b71e5a5059fe38476","title":"Promise","content":"Promise的理解和使用\npromise是一门新的技术(es6规范)\npromise是异步编程的新解决方案\n从语法上来说:promise是一个构造函数\n从功能上来说:promise对象用来封装异步操作并可以获取成功和失败的结果\npromise: 启动异步任务 &#x3D;&gt; 返回promise对象 &#x3D;&gt; 给promise对象绑定回调函数\n\npromise的优点支持链式调用,可以解决回调地狱问题\n\n\n\n\n\n\n\n\n\n什么是回调地狱？\n回调函数嵌套调用,外部回调函数异步执行的结果是嵌套的回调执行条件\n\n\n\n\n\n\n\n\n\n回调地狱的缺点？\n不便于阅读\n不便于异常处理\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;\n  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n  &lt;title&gt;Document&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  &lt;div class&#x3D;&quot;container&quot;&gt;\n    &lt;button class&#x3D;&quot;btn&quot; id&#x3D;&quot;btn&quot;&gt;点击抽奖&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;script&gt;\n  function rand(m,n) &#123;\n    return Math.ceil(Math.random()*(n-m+1)) + m+1\n  &#125;\n  let btn &#x3D;  document.querySelector(&quot;#btn&quot;)\n  btn.addEventListener(&#39;click&#39;,function()&#123;\n    &#x2F;&#x2F; 原生回调形式\n    &#x2F;&#x2F; setTimeout(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F;   let n &#x3D; rand(1,100)\n    &#x2F;&#x2F;   if(n &lt;&#x3D; 30) &#123;\n    &#x2F;&#x2F;     console.log(n)\n    &#x2F;&#x2F;     alert(&quot;恭喜中奖&quot;)\n    &#x2F;&#x2F;   &#125; else &#123;\n    &#x2F;&#x2F;     console.log(n)\n    &#x2F;&#x2F;     alert(&quot;谢谢惠顾&quot;)\n    &#x2F;&#x2F;   &#125;\n    &#x2F;&#x2F; &#125;,2000)\n    &#x2F;&#x2F; promise形式 promise有两个参数 resolve 返回成功操作\n    &#x2F;&#x2F; reject 表示失败操作  它可以包裹异步操作并对其进行封装\n    let p &#x3D;  new Promise((resolve, reject) &#x3D;&gt; &#123;\n      setTimeout(() &#x3D;&gt; &#123;\n      let n &#x3D; rand(1,100)\n      if(n &lt;&#x3D; 30) &#123;\n        console.log(n)\n        resolve() &#x2F;&#x2F; 将promise对象的状态设置为成功\n      &#125; else &#123;\n        console.log(n)\n        reject() &#x2F;&#x2F; 将promise对象的状态设置为失败\n      &#125;\n    &#125;,1000)\n    &#125;) \n    p.then(() &#x3D;&gt;&#123;\n      alert(&quot;恭喜中奖&quot;)\n    &#125;, () &#x3D;&gt; &#123;\n      alert(&#39;谢谢惠顾&#39;)\n    &#125;)\n  &#125;)\n&lt;&#x2F;script&gt;\n&lt;&#x2F;html&gt;\n\npromise的状态是实例对象[PromiseState]的一个属性它有3种状态 \n初始状态&#x2F;未决定的  pending \n当执行结果为成功时状态为pending会变为fullfilled\n当执行结果失败时状态为pending会变为rejected\n一个promise对象只能改变一次无论变为成功还是失败都会返回一个数据结果\n成功数据结果一般称为value\n失败数据结果一般称为reason\nPromise对象的值是实例对象的另一个属性[PromiseResult] 保存成功和失败的结果\n\n相关API\npromise构造函数: new Promise() 接收一个函数作为参数\n参数内部接收两个函数分别为 resolve(成功)  reject(失败) 它们分别执行失败和成功的回调\nPromise.protype.then方法 （’函数一’,’函数二’）&#x3D;&gt; {} \n指定用于得到一个成功或失败的回调返回一个新的promise对象\nPromise.protype.catch 方法 （）&#x3D;&gt; {}\n指定一个失败的回调\nPromise.resolve 方法 (value) &#x3D;&gt; {}\n传入的参数为非promise类型的对象,则返回的结果为成功的promise\n传入的参数为promise对象.则参数的结果决定了resolve的结果\nPromise.reject 方法() &#x3D;&gt; {}\n返回一个失败的promise对象\nPromise.all方法 ([]) &#x3D;&gt; {}\n包含n个promise数组 \n返回一个新的promise,只有所有的promise都成功才成功,只要失败了一个就直接失败\nPromise.race 方法 () &#x3D;&gt; {}\n包含n个promise的数组\n返回一个新的promise 第一个完成的promise的结果状态就是最终的结果状态\n","slug":"Promise的理解和使用","date":"2022-05-15T12:46:25.000Z","categories_index":"技术","tags_index":"ES6,JavaScript","author_index":"小提琴"},{"id":"e5c9682f958fbae18070afcafeff3ba8","title":"git命令","content":"安装完git之后第一件是就是设置自己的用户名和邮箱地址git config --global user.name “用户名&quot;\ngit config --global user.email &quot;邮箱&quot;\n\n\n如果是使用了–global选项,那么命令只需要运行一次,即可用户生效\n配置完用户名和邮箱后会被写入到c盘的用户文件夹的.gitcongih文件中可以自行查看\n\ngit快速查看全局配置信息查看所有配置 git config --list --global\n指定查看配置项 git config user.name 或 user.email\n\n获取帮助信息git help config 或 git config -h\n\n初始化git仓库git init\n\n\n输入命令后会创建一个名.git的隐藏目录,\n这个.git目录就是当前项目的git仓库\n里面包含了初始化必要文件\n\n查看文件状态的命令git status 或 加s表示精简\n\n一次性将文件加入暂存区的命令git add . 或 加入暂存区 git add &#39;文件名&#39;\n\n将暂存区的文件提交到git厂库命令git commit  -m “提交消息”\n\n克隆远程仓库git clone 远程仓库地址\n\n如果需要从暂存去中移除对应大的文件使用git reset HEAD &quot;移除文件”\n\n跳过使用暂存区域 直接跳过暂存区,将工作区中的修改直接提交到git仓库git commit -a -m “描述消息&quot;\n\n从工作区和git仓库移除文件git rm -f &quot;文件名&quot;   &#x2F;&#x2F; 只删除git仓库  git rm --cached &quot;文件名&quot;\n\n查看提交历史git log\n\n回退到指定版本在一行上展示所有的提交历史git log --pretty&#x3D;online\n\n根据指定的提交ID回退指定版本git reset --hard &lt;CommitID&gt;\n\n再次根据最新的提交ID,跳转到最新的版本git reset --hard &lt;CommitID&gt;\n\n快速生成SSHkey—-远程仓库配置使用ssh-keygen -t rsa -b 4096 -C &quot;邮箱&quot;\n\n\n会在c盘用户文件夹.ssh目录生成id_rsa和id_rsa.pub\n使用记事本打开id_rsa.pub文件,复制里面的文本内容\n在浏览器中登入github 点击头像-&gt; settings(设置)-&gt;进行秘钥配置\n将id_rsa.pub 文件中的内容 粘贴到key对应的文本框中\n填写一个名称用来标识key\n\n检测sshkey是否配置成功ssh -T git@github.com\n\n上述命令执行成功后,可能会看到提示消息 输入yes即可\n查看分支git branch *带表当前所在分支\n\n创建分支git branch 分支名称 创建完分支后当前还是在主分支\n\n切换分支git  checkout 分支名称\n\n快速创建一个分支 并立即切换到新分支git checkout -b 分支名称\n\n合并分支 首先切换到主分支 在主分支上使用git merge 分支名称\n\n删除分支git branch -d 分支名称\n\n遇到冲突时的分支合并如果在两个不同的分支中,对同一个文件进行了不同的修改,git就没法干净的合并它们此时需要手动解决冲突,打开包含冲突的文件\ngit add .\ngit commit -m &quot;&quot;\n\n将本地分支推送到远程仓库,第一次将本地分支推送到远程仓库需要使用git push -u 远程仓库名字 本地分支名称：远程分支名称\n实际案例:\ngit push -u origin payment:pay\n\n第一次推送分支需要带-u参数,此后可以直接使用git push推送代码到分支此后可以直接使用git push 推送代码到远程分支\n查看远程仓库分支列表git remote show &#39;远程仓库名称&#39;\n\n跟踪分支 从远程仓库中 把远程分支下载到本地仓库git checkout -b 本地分支名称 远程仓库名称&#x2F;远程分支名称\n示例: git checkout -b payment origin&#x2F;pay\n\n查看远程分支最新代码下载到本地对应文件中可以使用git pull\n\n删除远程分支git push &#39;远程仓库名称(origin)&#39; --delete &#39;远程分支名称&#39;\n\n查看本地密钥cat ~&#x2F;.ssh&#x2F;id_rsa.pub\n\n已有账号创建私钥ssh-keygen -t rsa -C&quot;邮箱&quot;\n\ngit上拉取指定分支git clone -b 分支名 &#39;克隆地址&#39;\n\n","slug":"git基础","date":"2022-05-15T12:46:25.000Z","categories_index":"技术","tags_index":"GIT","author_index":"小提琴"},{"id":"d5f81ad13155fc328e81b1032965290d","title":"Vuex","content":"Vuex专门在 Vue 中实现集中式状态管理的一个 Vue 插件,对 vue 应用中多个组件的共享状态进行集中式的管理,也是一种组件间通信的方式，且适用于任意组件间通信\n什么时候使用Vuex多个组件依赖同一状态\n来自不同组件的行为需要变更同一状态\nVuex工作原理图\nVuex基本环境&#x2F;&#x2F;引入Vue核心库\nimport Vue from &#39;vue&#39;\n&#x2F;&#x2F;引入Vuex\nimport Vuex from &#39;vuex&#39;\n&#x2F;&#x2F;应用Vuex插件\nVue.use(Vuex)\n   \n&#x2F;&#x2F;准备actions对象——响应组件中用户的动作、处理业务逻辑\nconst actions &#x3D; &#123;&#125;\n&#x2F;&#x2F;准备mutations对象——修改state中的数据\nconst mutations &#x3D; &#123;&#125;\n&#x2F;&#x2F;准备state对象——保存具体的数据\nconst state &#x3D; &#123;&#125;\n   \n&#x2F;&#x2F;创建并暴露store\nexport default new Vuex.Store(&#123;\n   \tactions,\n   \tmutations,\n   \tstate\n&#125;)\n\n初始化数据state, 配置actions, mutations\n组件中读取vuex中的数据: $store.state.”数据名”\n组件中修改vuex中的数据: $store.dispatch(‘actions的方法名’,数据)\n或$store.commit(“mutations中的方法名”,数据)\n若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写dispatch，直接编写commit&#96;\ngetters配置项当state中的数据需要经过加工后再使用时,可以使用getters加工\n在store.js中追加getters配置\nconst getters &#x3D; &#123;\n&#125;\n\n组件读取数据: $store.getters.”数据”\nmap方法的使用mapState: 用于映射state中的数据(一般用于计算属性)\ncomputed: &#123;\n    &#x2F;&#x2F;借助mapState生成计算属性：sum、school、subject（对象写法）\n     ...mapState(&#123;sum:&#39;sum&#39;,school:&#39;school&#39;,subject:&#39;subject&#39;&#125;),\n         \n    &#x2F;&#x2F;借助mapState生成计算属性：sum、school、subject（数组写法）\n    ...mapState([&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),\n&#125;,\n\nmapGetters:用于映射getters中的数据(一般用于计算属性)\ncomputed: &#123;\n    &#x2F;&#x2F;借助mapGetters生成计算属性：bigSum（对象写法）\n    ...mapGetters(&#123;bigSum:&#39;bigSum&#39;&#125;),\n\n    &#x2F;&#x2F;借助mapGetters生成计算属性：bigSum（数组写法）\n    ...mapGetters([&#39;bigSum&#39;])\n&#125;,\n\nmapActions方法:用于生成actions对话的方法(包含$store.dispath()函数)\nmethods:&#123;\n    &#x2F;&#x2F;靠mapActions生成：incrementOdd、incrementWait（对象形式）\n    ...mapActions(&#123;incrementOdd:&#39;jiaOdd&#39;,incrementWait:&#39;jiaWait&#39;&#125;)\n\n    &#x2F;&#x2F;靠mapActions生成：incrementOdd、incrementWait（数组形式）\n    ...mapActions([&#39;jiaOdd&#39;,&#39;jiaWait&#39;])\n&#125;\n\nmapMutations: 用于生成与mutations对话的方法(包含$store.commit()函数)\nmethods:&#123;\n    &#x2F;&#x2F;靠mapMutations生成：increment、decrement（对象形式）\n    ...mapMutations(&#123;increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;&#125;),\n    \n    &#x2F;&#x2F;靠mapMutations生成：JIA、JIAN（对象形式）\n    ...mapMutations([&#39;JIA&#39;,&#39;JIAN&#39;]),\n&#125;\n\nmapActions与mapMutations使用时，若需要传递参数，则需要在模板中绑定事件时传递好参数，否则参数是事件对象\n","slug":"Vuex","date":"2022-05-13T12:46:25.000Z","categories_index":"技术","tags_index":"Vue,JavaScript","author_index":"小提琴"}]